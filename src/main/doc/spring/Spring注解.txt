@Api：
@ApiOperation：
不是Spring自带的注解，是svagger里的
com.worknik.swagger.annotations.Api
com.worknik.swagger.annotations.ApiOperation
@ApiOperatoin和@ApiParam为添加的API提供相应的注解，各个参数说明如下：
@ApiOperation(value = "为在Swagger-UI的适当的可见性，提供120个字符或以下的一个简短的说明", httpMethod = "接口请求的方式，http请求的方式，例如GET，POST等", response = "接口返回参数类型", notes = "提供关于这个操作的冗长的描述", position = "在资源列表中可选的这个API资源的显式排序")
其它参数可参考源码说明。
@ApiParam(required = true or false 是否需要参数, name = "参数名称", value = "参数简短描述")
实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。
Swagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目
实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档，
同时swagger-ui还可以测试spring restful风格的接口功能。

@Resource 和 @Autowired
1、共同点
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。
2、不同点
@Resource(import javax.annotation.Resource;)是J2EE的注解，但是Spring支持该注解的注入。
@Autowired(import org.springframework.beans.factory.annotation.Autowired;)是Spring的注解
@Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式（byType）进行bean匹配
@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用
@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。
注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。
@Resource装配顺序：
①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。
②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。
③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。
④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。
@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。
例如一个接口只有一个实现时：
接口：
package com.jef.service;

public interface IHumanService {
    void speak();

    void walk();
}


实现类1：
package com.jef.service.impl;

import com.jef.service.IHumanService;
import org.springframework.stereotype.Service;

/**
 * 男人
 * @author Jef
 * @create 2018/5/12 14:31
 */
@Service(value = "manService")
public class ManServiceImpl implements IHumanService {

    @Override
    public void speak() {
        System.out.println("男人说话");
    }

    @Override
    public void walk() {
        System.out.println("男人走路");
    }
}


那么此时
@Resource
private IHumanService manService;
和
@Autowired
private IHumanService manService;
无需设置其他属性值，都能正确加载Service，因为此时有且只有一个Service实现类可以找到
但是如果实现类有多个呢？
添加了一个实现
package com.jef.service.impl;

import com.jef.service.IHumanService;
import org.springframework.stereotype.Service;

/**
 * 女人
 * @author Jef
 * @create 2018/5/12 14:31
 */
@Service(value = "womanService")
public class WomanServiceImpl implements IHumanService {

    @Override
    public void speak() {
        System.out.println("女人说话");
    }

    @Override
    public void walk() {
        System.out.println("女人走路");
    }
}


启动项目会产生
NoSuchBeanDefinitionException: No unique bean of type错误，原因是没有特定指明是哪一个
方式一：指定某一个，默认name的值为实现类首字母小写
    @Resource(name = "manServiceImpl")
    private IHumanService manService;
    @Resource(name = "womanServiceImpl")
    private IHumanService womanService;

方式2：
    @Autowired
    @Qualifier(value = "manServiceImpl")
    private IHumanService manService;
    @Autowired
    @Qualifier(value = "womanServiceImpl")
    private IHumanService womanService;
如果感觉name或者value的名称不好看，可以修改@Service里面的value，格式如下
@Service(value = "manService")
@Service(value = "womanService")
那么@Resource的name和@Autowired的value都可以改成相应的value
方式一：指定某一个，默认name的值为实现类首字母小写
    @Resource(name = "manService")
    private IHumanService manService;
    @Resource(name = "womanService")
    private IHumanService womanService;

方式2：
    @Autowired
    @Qualifier(value = "manService")
    private IHumanService manService;
    @Autowired
    @Qualifier(value = "womanService")
    private IHumanService womanService;

@Controller
在SpringMVC中，控制器Controller负责处理DispatcherServlet分发的请求，它把用户请求的路径经过业务处理层处理之后封装成一个Model，然后再把该Model返回给对应的View进行展示。在SpringMVC
中提供了一个非常简便的Controller的方法，你无须继承特定的类或实现特定的接口，只需使用@Controller标记一个类是Controller，然后使用@RequestMapping和@RequestParam等一些注释用以定义URL
请求和Controller方法之间的映射，这样的Controller就能被外界访问到。此外，Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet
对象，它们可以通过@Controller的方法参数灵活的获取到。
@Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller
只是定义了一个控制器类，而使用@RequestMapping注解的方法才是真正处理请求的处理器。单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC的一个控制器类，因为这个时候Spring
还不认识它。那么要如何做Spring才能认识它了？这个是否就需要我们把这个控制器类交给Spring来管理。有两种方式：
1）在SpringMVC的配置文件中定义对应你的***Controller的bean对象
<bean class="com.jef.controller.***Controller" />
2）在SpringMVC的配置文件中告诉Spring该到哪里去找标记为@Controller的Controller的控制器。
<context:component-scan base-package="com.jef.controller"/> // 也可以直接将路径配置为controller的上一层，这样如果service等也可以被扫描到

@RequestMapping
RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。
1、 value，method；
value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
method：指定请求的method类型，GET、POST、PUT、DELETE等；
2、consumes，produces
consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；
3、params，headers
params：指定request中必须包含某些参数值是，才让该方法处理。
headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。

@ModelAttribute和@SessionAttributes
@ModelAttribute代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。
@SessionAttributes即将值放到session作用域中，写在class上面。
具体示例参见下面：使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据
SpringMVC支持使用@ModelAttribute和@SessionAttributes在不同的模型（model）和控制器之间共享数据。@ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在Controller方法参数上。
当@ModelAttribute标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在session或模型属性中，属性名称可以使用@ModelAttribute("attributeName")
在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。

@PathVariable
用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。一般用于GET请求。

@RequestParam
@RequestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter("name")，它有三个常用参数：defaultValue = "0", required = false,
value = "isApp"；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。

@ResponseBody
作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；

@Component
相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。

@Repository
用于注解dao层，在daoImpl类上面注解。

使用 @RequestMapping 的一些高级用法
（1）params属性
@RequestMapping(value= "testParams", params={ "param1=value1" , "param2" , "!param3" })
    public String testParams() {
       return "testParams" ;
    }
用@RequestMapping的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1的值必须等于value1 ，参数param2必须存在，值无所谓，参数param 必须不存在，只有当请求/testParams 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams?param1=value1&param2=value2 的时候能够正确访问到该testParams方法，当请求/testParams?param1=value1&param2=value2&param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping的params参数里面指定了参数param3是不能存在的。
（2）method属性
@RequestMapping(value= "testMethod", method={RequestMethod.GET, RequestMethod.DELETE})
    public String testMethod() {
       return "method" ;
    }
在上面的代码中就使用method参数限制了以GET或DELETE 方法请求/testMethod的时候才能访问到该Controller的testMethod方法。
（3）headers属性
@RequestMapping(value = "testHeaders", headers={"host=localhost" , "Accept"})
    public String testHeaders() {
       return "headers" ;
    }
headers属性的用法和功能与params属性相似。在上面的代码中当请求/testHeaders的时候只有当请求头包含Accept信息，且请求的host 为localhost的时候才能正确的访问到testHeaders方法。

@RequestHeader、@CookieValue
@RequestHeader注解，可以把Request请求header部分的值绑定到方法的参数上。
示例代码：
这是一个Request的header部分：
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
@RequestMapping("/displayHeaderInfo.do")
public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding,
                              @RequestHeader("Keep-Alive") long keepAlive)  {
}
上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。
@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。
例如有如下Cookie值：
　　JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
@RequestMapping("/displayHeaderInfo.do")
public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie)  {
}
即把JSESSIONID的值绑定到参数cookie上。


@RequestMapping 标记的处理器方法支持的方法参数和返回类型
1. 支持的方法参数类型
   （1 ）HttpServlet对象，主要包括HttpServletRequest、HttpServletResponse 和HttpSession对象。 这些参数Spring在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession对象的时候，如果此时HttpSession对象还没有建立起来的话就会有问题。
   （2 ）Spring自己的WebRequest对象。 使用该对象可以访问到存放在HttpServletRequest和HttpSession中的属性值。
   （3 ）InputStream、OutputStream、Reader和Writer。InputStream和Reader是针对HttpServletRequest而言的，可以从里面取数据；OutputStream和Writer是针对HttpServletResponse而言的，可以往里面写数据。
   （4 ）使用@PathVariable、@RequestParam、@CookieValue 和@RequestHeader标记的参数。
   （5 ）使用@ModelAttribute标记的参数。
   （6 ）java.util.Map、Spring封装的Model和ModelMap。这些都可以用来封装模型数据，用来给视图做展示。
   （7 ）实体类。可以用来接收上传的参数。
   （8 ）Spring封装的MultipartFile。用来接收上传文件的。
   （9 ）Spring封装的Errors和BindingResult对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。
2. 支持的返回类型
   （1 ）一个包含模型和视图的ModelAndView 对象。
   （2 ）一个模型对象，这主要包括Spring封装好的Model和ModelMap，以及java.util.Map，当没有视图返回的时候视图名称将由RequestToViewNameTranslator来决定。
   （3 ）一个View对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。
   （4 ）一个String字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。
   （5 ）返回值是void。这种情况一般是我们直接把返回结果写到HttpServletResponse中了，如果没有写的话，那么Spring将会利用RequestToViewNameTranslator来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。
   （6 ）如果处理器方法被注解@ResponseBody标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters转换之后写到HttpServletResponse中，而不会像上面的那些情况一样当做视图或者模型来处理。
   （7 ）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute
   ("attributeName")来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute标记的方法会在@RequestMapping标记的方法执行之前执行。

