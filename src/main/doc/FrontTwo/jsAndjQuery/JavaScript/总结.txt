JS基础：
热身：
为什么学习JavaScript
一、你知道，为什么JavaScript非常值得我们学习吗？
1. 所有主流浏览器都支持JavaScript。
2. 目前，全世界大部分网页都使用JavaScript。
3. 它可以让网页呈现各种动态效果。
4. 做为一个Web开发师，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。
二、易学性
1.学习环境无外不在，只要有文本编辑器，就能编写JavaScript程序。
2.我们可以用简单命令，完成一些基本操作。
三、从哪开始学习呢？
学习JavaScript的起点就是处理网页，所以我们先学习基础语法和如何使用DOM进行简单操作。
index.html

我们来看看如何写入JS代码？你只需一步操作,使用<script>标签在HTML网页中插入JavaScript代码。
注意， <script>标签要成对出现，并把JavaScript代码写在<script></script>之间。
<script type="text/javascript">表示在<script></script>之间的是文本类型(text),javascript是为了告诉浏览器里面的文本是属于JavaScript语言。
writeinto.html

我也可以独立（引用JS外部文件）
通过前面知识学习，我们知道使用<script>标签在HTML文件中添加JavaScript代码，如图:
JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。
注意:在JS文件中，不需要<script>标签,直接编写JavaScript代码就可以了。
JS文件不能直接运行，需嵌入到HTML文件中执行，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。
<script src="script.js"></script>
注意：在编辑器中有html文件和script.js文件
importjs.html&&js/script.js

找到你的位置（JS在页面中的位置）
我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。
放在<head>部分
最常用的方式是在页面中head部分放置<script>元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。
放在<body>部分
JavaScript代码在网页读取到该语句的时候就会执行。
注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。
anyLocation.html

认识语句和符号
JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。
每一句JavaScript代码格式: 语句;
先来看看下面代码
<script type="text/javascript">
   alert("hello!");
</script>
例子中的alert("hello!");就是一个JavaScript语句。
一行的结束就被认定为语句的结束，通常在结尾加上一个分号";"来表示语句的结束。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。
注意：让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教程中，我们不会省略;，所有语句都会添加;。
看看下面这段代码,有三条语句，每句结束后都有";"，按顺序执行语句。
<script type="text/javascript">
   document.write("I");
   document.write("love");
   document.write("JavaScript");
</script>
注意:
1. “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。
2. 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。
StatementsAndsymbols.html

注释很重要
注释的作用是提高代码的可读性，帮助自己和别人阅读和理解你所编写的JavaScript代码，注释的内容不会在网页中显示。注释可分为单行注释与多行注释两种。
我们为了方便阅读，注释内容一般放到需要解释语句的结尾处或周围。
单行注释，在注释内容前加符号 “//”。
<script type="text/javascript">
  document.write("单行注释使用'//'");  // 我是注释，该语句功能在网页中输出内容
</script>
多行注释以"/*"开始，以"*/"结束。
<script type="text/javascript">
   document.write("多行注释使用/*注释内容*/");
   /*
    多行注释
    养成书写注释的良好习惯
   */
</script>
annotation.html

第2章 你要懂的规则(JS基础语法)
什么是变量
什么是变量? 从字面上看，变量是可变的量；从编程角度讲，变量是用于存储某种/某些数值的存储器。我们可以把变量看做一个盒子，为了区分盒子，可以用BOX1,BOX2等名称代表不同盒子，BOX1就是盒子的名字（也就是变量的名字）。
定义变量使用关键字var,语法如下：
var 变量名
变量名可以任意取名，但要遵循命名规则:
    1.变量必须使用字母、下划线(_)或者美元符($)开始。
    2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。
    3.不能使用JavaScript关键词与JavaScript保留字。
变量要先声明再赋值，如下：
var mychar;
mychar = "javascript";
var mynum = 6;
变量可以重复赋值，如下：
var mychar;
mychar = "javascript";
mychar = "hello";
注意:
1. 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。
2. 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。
variable.html

判断语句（if...else）
if...else语句是在指定的条件成立时执行代码，在条件不成立时执行else后的代码。
语法:
if(条件)
{ 条件成立时执行的代码 }
else
{ 条件不成立时执行的代码 }
其中else语句是可选的。如果语句块只包含一条语句，那么可以省略{}：
var age = 20;
if (age >= 18)
    alert("adult");
else
    alert("teenager");
省略{}的危险之处在于，如果后来想添加一些语句，却忘了写{}，就改变了if...else...的语义，例如：
var age = 20;
if (age >= 18)
    alert("adult");
else
    console.log("age < 18"); // 添加一行日志
    alert("teenager"); // <- 这行语句已经不在else的控制范围了
上述代码的else子句实际上只负责执行console.log("age < 18");，原有的alert("teenager");已经不属于if...else...的控制范围了，它每次都会执行。
相反地，有{}的语句就不会出错：
var age = 20;
if (age >= 18) {
    alert("adult");
} else {
    console.log("age < 18");
    alert("teenager");
}
这就是为什么我们建议永远都要写上{}。
如果if的条件判断语句结果不是true或false怎么办？例如：
var s = "123";
if (s.length) { // 条件计算结果为3
    //
}
JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，因此上述代码条件判断的结果是true。
假设我们通过年龄来判断是否为成年人，如年龄大于等于18岁，是成年人，否则不是成年人。代码表示如下:

<script type="text/javascript">
   var myage = 18;
   if(myage >= 18)  //myage>=18是判断条件
   { document.write("你是成年人。");}
   else  //否则年龄小于18
   { document.write("未满18岁，你不是成年人。");}
</script>
ifelse.html

什么是函数
函数是完成某个特定功能的一组语句。如没有函数，完成任务可能需要五行、十行、甚至更多的代码。这时我们就可以把完成特定功能的代码块放到一个函数里，直接调用这个函数，就省重复输入大量代码的麻烦。
如何定义一个函数呢？基本语法如下:
function 函数名()
{
     函数代码;
}
说明:
1. function定义函数的关键字。
2. "函数名"你为函数取的名字。
3. "函数代码"替换为完成特定功能的代码。
我们来编写一个实现两数相加的简单函数,并给函数起个有意义的名字：“add2”，代码如下：
function add2(){
   var sum = 3 + 2;
   alert(sum);
}
由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。
因此，第二种定义函数的方式如下：
var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
};
在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。
上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。
函数调用:
函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数，按顺序传入参数就可以了,代码如下:
abs(10); // 返回10
abs(-9); // 返回9
由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：
abs(10, "blablabla"); // 返回10
abs(-9, "haha", "hehe", null); // 返回9
传入的参数比定义的少也没有问题：
abs(); // 返回NaN
此时abs(x)函数的参数x将收到undefined，计算结果为NaN。
要避免收到undefined，可以对参数进行检查：
function abs(x) {
    if (typeof x !== "number") {
        throw "Not a number";
    }
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
小心你的return语句
前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：
function foo() {
    return { name: "foo" };
}
foo(); // { name: "foo" }
如果把return语句拆成两行：
function foo() {
    return
        { name: "foo" };
}
foo(); // undefined
要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：

function foo() {
    return; // 自动添加了分号，相当于return undefined;
        { name: "foo" }; // 这行语句已经没法执行到了
}
所以正确的多行写法是：
function foo() {
    return { // 这里不会自动加分号，因为{表示语句尚未结束
        name: "foo"
    };
}
function.html

变量作用域：
在JavaScript中，用var申明的变量实际上是有作用域的。

如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：
function foo() {
    var x = 1;
    x = x + 1;
}

x = x + 2; // ReferenceError! 无法在函数体外引用变量x
如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：
function foo() {
    var x = 1;
    x = x + 1;
}

function bar() {
    var x = "A";
    x = x + "B";
}
由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：
function foo() {
    var x = 1;
    function bar() {
        var y = x + 1; // bar可以访问foo的变量x!
    }
    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
}
如果内部函数和外部函数的变量名重名怎么办？
function foo() {
    var x = 1;
    function bar() {
        var x = "A";
        alert("x in bar() = " + x); // "A"
    }
    alert("x in foo() = " + x); // 1
    bar();
}
这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。

变量提升:
JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：
function foo() {
    var x = "Hello, " + y;
    alert(x);
    var y = "Bob";
}
foo();
虽然是strict模式，但语句var x = "Hello, " + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。
对于上述foo()函数，JavaScript引擎看到的代码相当于：
function foo() {
    var y; // 提升变量y的申明
    var x = "Hello, " + y;
    alert(x);
    y = "Bob";
}
由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：
function foo() {
    var
        x = 1, // x初始化为1
        y = x + 1, // y初始化为2
        z, i; // z和i为undefined
    // 其他语句:
    for (i=0; i<100; i++) {
        ...
    }
}

全局作用域：
不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：
var course = "Learn JavaScript";
alert(course); // "Learn JavaScript"
alert(window.course); // "Learn JavaScript"
因此，直接访问全局变量course和访问window.course是完全一样的。
你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：
function foo() {
    alert("foo");
}
foo(); // 直接调用foo()
window.foo(); // 通过window.foo()调用
进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：
window.alert("调用window.alert()");
// 把alert保存到另一个变量:
var old_alert = window.alert;
// 给alert赋一个新函数:
window.alert = function () {}
alert("无法用alert()显示了!");

// 恢复alert:
window.alert = old_alert;
alert("又可以用alert()了!");
或者是刷新页面也可以起到恢复alert的作用
这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。

名字空间：
全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。
减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：
// 唯一的全局变量MYAPP:
var MYAPP = {};
// 其他变量:
MYAPP.name = "myapp";
MYAPP.version = 1.0;
// 其他函数:
MYAPP.foo = function () {
    return "foo";
};
把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。
许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。
局部作用域
由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：
function foo() {
    for (var i=0; i<100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}
为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：
function foo() {
    var sum = 0;
    for (let i=0; i<100; i++) {
        sum += i;
    }
    i += 1; // SyntaxError
}

常量：
由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：
var PI = 3.14;
ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14

方法：
在一个对象中绑定函数，称为这个对象的方法。
在JavaScript中，对象的定义是这样的：
var xiaoming = {
    name: "小明",
    birth: 1990
};
但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：
var xiaoming = {
    name: "小明",
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？
在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。
让我们拆开写：

function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: "小明",
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。
JavaScript的函数内部如果调用了this，那么这个this到底指向谁？
答案是，视情况而定！
如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。
如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。
坑爹啊！
更坑爹的是，如果这么写：
var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！
由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：
"use strict";
var xiaoming = {
    name: "小明",
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property "birth" of undefined
这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。

有些时候，喜欢重构的你把方法重构了一下：
var xiaoming = {
    name: "小明",
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property "birth" of undefined
结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）
修复的办法也不是没有，我们用一个that变量首先捕获this：
var xiaoming = {
    name: "小明",
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};
xiaoming.age(); // 25
用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。

apply：
虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！
要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
用apply修复getAge()调用：
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: "小明",
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
另一个与apply()类似的方法是call()，唯一区别是：
apply()把参数打包成Array再传入；
call()把参数按顺序传入。
比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
对普通函数调用，我们通常把this绑定为null。

装饰器：
利用apply()，我们还可以动态改变函数的行为。
JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。
现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：
var count = 0;
var oldParseInt = parseInt; // 保存原函数
window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};
// 测试:
parseInt("10");
parseInt("20");
parseInt("30");
count; // 3

高阶函数：
高阶函数英文叫Higher-order function。那么什么是高阶函数？
JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
一个最简单的高阶函数：
function add(x, y, f) {
    return f(x) + f(y);
}
当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为：
x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
用代码验证一下：
add(-5, 6, Math.abs); // 11
编写高阶函数，就是让函数的参数能够接收别的函数。

map/reduce：
map
举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下：
由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果：
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
map()传入的参数是pow，即函数对象本身。
你可能会想，不需要map()，写一个循环，也可以计算出结果：
var f = function (x) {
    return x * x;
};
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var result = [];
for (var i=0; i<arr.length; i++) {
    result.push(f(arr[i]));
}
的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。
所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String); // ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
只需要一行代码。

reduce
再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
比方说对一个Array求和，就可以用reduce实现：
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25
要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579
如果我们继续改进这个例子，想办法利用map()把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，和reduce()就可以写出一个把字符串转换为Number的函数。
练习：不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数：
function string2int(s) {
    var arr = s.split("");
    console.log(arr);
    var arr2 = arr.map(function(x){
      return x * 1;
	})
	console.log(arr2);
    var result = arr2.reduce(function(x, y) {
    	return x * 10 + y;
    })
    console.log(result);
    return result;
}
// 测试:
if (string2int("0") === 0 && string2int("12345") === 12345 && string2int("12300") === 12300) {
    if (string2int.toString().indexOf("parseInt") !== -1) {
        alert("请勿使用parseInt()!");
    } else if (string2int.toString().indexOf("Number") !== -1) {
        alert("请勿使用Number()!");
    } else {
        alert("测试通过!");
    }
}
else {
    alert("测试失败!");
}
也可以用箭头函数实现：
function string2int(s) {
    return s.split('')    // 分割成字符数组
    .map(x => x*1)  // 快速转换成数字
    .reduce((x, y) => (10*x +y));
}
// 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']
    return arr.map(name => name.toLowerCase())      // 每个名字全部字母小写
              .map(name => (name[0].toUpperCase() + name.substring(1)));    // 首字母大写

filter：
filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。
和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：
var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
把一个Array中的空字符串删掉，可以这么写：
var arr = ["A", "", "B", null, undefined, "C", "  "];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
arr; // ["A", "B", "C"]
可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。
调函数

filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：
var arr = ['A', 'B', 'C'];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 依次打印'A', 'B', 'C'
    console.log(index); // 依次打印0, 1, 2
    console.log(self); // self就是变量arr
    return true;
});
利用filter，可以巧妙地去除Array的重复元素：
var
    r,
    arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];
r = arr.filter(function (element, index, self) {
    return self.indexOf(element) === index;
});
alert(r.toString());
原理：去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。

闭包：
函数作为返回值
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：
function sum(arr) {
    return arr.reduce(function (x, y) {
        return x + y;
    });
}
sum([1, 2, 3, 4, 5]); // 15
但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！
function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}
当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()
调用函数f时，才真正计算求和的结果：
f(); // 15
在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：
var f1 = lazy_sum([1, 2, 3, 4, 5]);
var f2 = lazy_sum([1, 2, 3, 4, 5]);
f1 === f2; // false
f1()和f2()的调用结果互不影响。

闭包
注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}
var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。
你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：
f1(); // 16
f2(); // 16
f3(); // 16
全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。
返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}
var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
f1(); // 1
f2(); // 4
f3(); // 9
注意这里用了一个“创建一个匿名函数并立刻执行”的语法：
(function (x) {
    return x * x;
})(3); // 9
理论上讲，创建一个匿名函数并立刻执行可以这么写：
function (x) { return x * x } (3);
但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：
(function (x) { return x * x }) (3);
通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：
(function (x) {
    return x * x;
})(3);
说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？
当然不是！闭包有非常强大的功能。举个栗子：
在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。
在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
它用起来像这样：
var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3
var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。
闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：
function make_pow(n) {
    return function (x) {
        return Math.pow(x, n);
    }
}
// 创建两个新函数:
var pow2 = make_pow(2);
var pow3 = make_pow(3);
pow2(5); // 25
pow3(7); // 343
脑洞大开
很久很久以前，有个叫阿隆佐·邱奇的帅哥，发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号。
JavaScript支持函数，所以可以用JavaScript用函数来写这些计算。来试试：
// 定义数字0:
var zero = function (f) {
    return function (x) {
        return x;
    }
};

// 定义数字1:
var one = function (f) {
    return function (x) {
        return f(x);
    }
};

// 定义加法:
function add(n, m) {
    return function (f) {
        return function (x) {
            return m(f)(n(f)(x));
        }
    }
}
// 计算数字2 = 1 + 1:
var two = add(one, one);
// 计算数字3 = 1 + 2:
var three = add(one, two);
// 计算数字5 = 2 + 3:
var five = add(two, three);
// 你说它是3就是3，你说它是5就是5，你怎么证明？
// 呵呵，看这里:
// 给3传一个函数,会打印3次:
(three(function () {
    console.log('print 3 times');
}))();
// 给5传一个函数,会打印5次:
(five(function () {
    console.log('print 5 times');
}))();
// 继续接着玩一会...

箭头函数：
ES6标准新增了一种新的函数：Arrow Function（箭头函数）。
为什么叫Arrow Function？因为它的定义用的就是一个箭头：
x => x * x
上面的箭头函数相当于：
function (x) {
    return x * x;
}
箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return：
x => {
    if (x > 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
如果参数不是一个，就需要用括号()括起来：
// 两个参数:
(x, y) => x * x + y * y
// 无参数:
() => 3.14
// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：
// SyntaxError:
x => { foo: x }
因为和函数体的{ ... }有语法冲突，所以要改为：
// ok:
x => ({ foo: x })

this：
箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。
回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
如果使用箭头函数，以前的那种hack写法：
var that = this;
就不再需要了。
由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：
var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25

generator：
generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。
ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补Python教程！。
我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：
function foo(x) {
    return x + x;
}
var r = foo(1); // 调用foo函数
函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。
generator跟函数很像，定义如下：
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。
大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？
还是举个栗子吧。
我们以一个著名的斐波那契数列为例，它由0，1开头：
0 1 1 2 3 5 8 13 21 34 ...
要编写一个产生斐波那契数列的函数，可以这么写：
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        t = a + b;
        a = b;
        b = t;
        arr.push(t);
    }
    return arr;
}
// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：
function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 1;
    while (n < max) {
        yield a;
        t = a + b;
        a = b;
        b = t;
        n ++;
    }
    return a;
}
直接调用试试：
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。
调用generator对象有两个方法，一是不断地调用generator对象的next()方法：
var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: true}
next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。
当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。
第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：
for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3
}
generator和普通函数相比，有什么用？
因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：
var fib = {
    a: 0,
    b: 1,
    n: 0,
    max: 5,
    next: function () {
        var
            r = this.a,
            t = this.a + this.b;
        this.a = this.b;
        this.b = t;
        if (this.n < this.max) {
            this.n ++;
            return r;
        } else {
            return undefined;
        }
    }
};
用对象的属性来保存状态，相当繁琐。
generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。
没有generator之前的黑暗时代，用AJAX时需要这么写代码：
ajax('http://url-1', data1, function (err, result) {
    if (err) {
        return handle(err);
    }
    ajax('http://url-2', data2, function (err, result) {
        if (err) {
            return handle(err);
        }
        ajax('http://url-3', data3, function (err, result) {
            if (err) {
                return handle(err);
            }
            return success(result);
        });
    });
});
回调越多，代码越难看。
有了generator的美好时代，用AJAX时可以这么写：
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
}
看上去是同步的代码，实际执行是异步的。
练习
要生成一个自增的ID，可以编写一个next_id()函数：
var current_id = 0;
function next_id() {
    current_id ++;
    return current_id;
}
由于函数无法保存状态，故需要一个全局变量current_id来保存数字。
不用闭包，试用generator改写：


输出内容（document.write）
document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。
第一种:输出内容用""括起，直接输出""号内的内容。
<script type="text/javascript">
  document.write("I love JavaScript！"); //内容用""括起来，""里的内容直接输出。
</script>
第二种:通过变量，输出内容
<script type="text/javascript">
  var mystr = "hello world!";
  document.write(mystr);  //直接写变量名，输出变量存储的内容。
</script>
第三种:输出多项内容，内容之间用+号连接。
<script type="text/javascript">
  var mystr = "hello";
  document.write(mystr + "I love JavaScript"); //多项内容之间用+号连接
</script>
第四种:输出HTML标签，并起作用，标签使用""括起来。
<script type="text/javascript">
  var mystr = "hello";
document.write(mystr + "<br />");//输出hello后，输出一个换行符
  document.write("JavaScript");
</script>
拓展：JS中如何输出空格
在写JS代码的时候，大家可以会发现这样现象:
document.write("   1      2                3  ");
结果: 1 2 3
无论在输出的内容中什么位置有多少个空格，显示的结果好像只有一个空格。
这是因为浏览器显示机制，对手动敲入的空格，将连续多个空格显示成1个空格。
解决方法:
1. 使用输出html标签&nbsp;来解决
 document.write("&nbsp;&nbsp;" + "1" + "&nbsp;&nbsp;&nbsp;&nbsp;" + "23");
 结果:  1    23
2. 使用CSS样式来解决
 document.write("<span style='white-space:pre;'>"+"  1        2    3    "+"</span>");
 结果:  1       2     3
 在输出时添加“white-space:pre;”样式属性。这个样式表示"空白会被浏览器保留"
documentwrite.html

警告（alert 消息对话框）
我们在访问网站的时候，有时会突然弹出一个小窗口，上面写着一段提示信息文字。如果你不点击“确定”，就不能对网页做任何操作，这个小窗口就是使用alert实现的。
语法:
alert(字符串或变量);
看下面的代码:
<script type="text/javascript">
   var mynum = 30;
   alert("hello!");
   alert(mynum);
</script>
注:alert弹出消息对话框(包含一个确定按钮)。
结果:按顺序弹出消息框
alert.html

确认（confirm 消息对话框）
confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。
语法:
confirm(str);
参数说明:
str：在消息对话框中要显示的文本
返回值: Boolean值
返回值:
当用户点击"确定"按钮时，返回true
当用户点击"取消"按钮时，返回false
注: 通过返回值可以判断用户点击了什么按钮
看下面的代码:
<script type="text/javascript">
    var mymessage = confirm("你喜欢JavaScript吗?");
    if(mymessage == true)
    {   document.write("很好,加油!");   }
    else
    {  document.write("JS功能强大，要学习噢!");   }
</script>
注: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。
confirm.html

提问（prompt 消息对话框）
prompt弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。
语法:
prompt(str1, str2);
参数说明：
str1: 要显示在消息对话框中的文本，不可修改
str2：文本框中的内容，可以修改
返回值:
1. 点击确定按钮，文本框中的内容将作为函数返回值
2. 点击取消按钮，将返回null
看看下面代码:
var myname=prompt("请输入你的姓名:");
if(myname != null)
  {   alert("你好" + myname); }
else
  {  alert("你好 my friend.");  }
结果:
注:在用户点击对话框的按钮前，不能进行任何其它操作。

打开新窗口（window.open）
open() 方法可以查找一个已经存在或者新建的浏览器窗口。
语法：
window.open([URL], [窗口名称], [参数字符串])
参数说明:
URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
窗口名称：可选参数，被打开窗口的名称。
    1.该名称由字母、数字和下划线字符组成。
    2."_top"、"_blank"、"_selft"具有特殊意义的名称。
       _blank：在新窗口显示目标网页
       _self：在当前窗口显示目标网页
       _top：框架网页中在上部窗口中显示目标网页
    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
    4.name 不能包含有空格。
参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。
参数表:
参数      值        说明
top    Number      窗口顶部离开屏幕顶部的像素数
left    Number      窗口顶部离开屏幕左部的像素数
width    Number      窗口的宽度
height    Number      窗口的宽度
menubar    yes,no      窗口有没有菜单
toolbar     yes,no      窗口有没有工具条
scrollbar    yes,no      窗口有没有滚动条
status        yes,no      窗口有没有状态栏
例如:打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：
<script type="text/javascript"> window.open("http://www.imooc.com", "_blank", "width = 300, height = 200, menubar = no, toolbar = no, status = no, scrollbars = yes")
</script>
注意：运行结果考虑浏览器兼容问题。
windowopen.html

关闭窗口（window.close）
close()关闭窗口
用法：
window.close();   //关闭本窗口
或
<窗口对象>.close();   //关闭指定的窗口
例如:关闭新建的窗口。
<script type="text/javascript">
   var mywin=window.open('http://www.imooc.com'); //将新打的窗口对象，存储在变量mywin中
   mywin.close();
</script>
注意:上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。
windowclose.html

编程练习
制作新按钮，“新窗口打开网站” ，点击打开新窗口。
practice1.html

认识DOM
文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。
HTML文档可以说由节点构成的集合，三种常见的DOM节点:
1. 元素节点：上图中<html>、<body>、<p>等都是元素节点，即标签。
2. 文本节点:向用户展示的内容，如<li>...</li>中的JavaScript、DOM、CSS等文本。
3. 属性节点:元素属性，如<a>标签的链接属性href="http://www.imooc.com"。
看下面代码:
<a href="http://www.imooc.com">JavaScript DOM</a>

通过ID获取元素
学过HTML/CSS样式，都知道，网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。
语法:
 document.getElementById(“id”)
结果:null或[object HTMLParagraphElement]
注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。
getById.html

innerHTML 属性
innerHTML 属性用于获取或替换 HTML 元素的内容。
语法:
Object.innerHTML
注意:
1.Object是获取的元素对象，如通过document.getElementById("ID")获取的元素。
2.注意书写，innerHTML区分大小写。
我们通过id="con"获取<p> 元素，并将元素的内容输出和改变元素内容
innerHTML.html

改变 HTML 样式
HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？
语法:
Object.style.property = new style;
注意:Object是获取的元素对象，如通过document.getElementById("id")获取的元素。
基本属性表（property）:
属性                    描述
backgroundColor       设置元素的背景颜色
width                 设置元素的宽度
height                设置元素的高度
color                 设置文本的颜色
font                  在同一行设置所有的字体属性
fontFamaly            设置元素的字体系列
fontSize              设置元素的字体大小
注意:该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。
看看下面的代码:
改变 <p> 元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：
<p id="pcon">Hello World!</p>
<script>
   var mychar = document.getElementById("pcon");
   mychar.style.color = "red";
   mychar.style.fontSize = "20";
   mychar.style.backgroundColor = "blue";
</script>
changeStyle.html

显示和隐藏（display属性）
网页中经常会看到显示和隐藏的效果，可通过display属性来设置。
语法：
Object.style.display = value
注意:Object是获取的元素对象，如通过document.getElementById("id")获取的元素。
value取值:
值       描述
none     此元素不会被显示（即隐藏）
block    此元素将显示为块级元素（即显示）

控制类名（className 属性）
className 属性设置或返回元素的class 属性。
语法：
object.className = classname
作用:
1.获取元素的class 属性
2. 为网页内的某个元素指定一个css样式来更改该元素的外观
看看下面代码，获得 <p> 元素的 class 属性和改变className：
className.html

编程挑战
小伙伴们，请编写"改变颜色"、"改变宽高"、"隐藏内容"、"显示内容"、"取消设置"的函数，点击相应按钮执行相应操作，点击"取消设置"按钮后，提示是否取消设置，如是执行操作，否则不做操作。
任务
一、定义"改变颜色"的函数
提示:
obj.style.color
obj.style.backgroundColor
二、定义"改变宽高"的函数
提示:
obj.style.width
obj.style.height
三、定义"隐藏内容"的函数
提示:
obj.style.display = "none";
四、定义"显示内容"的函数
提示:
obj.style.display = "block";
五、定义"取消设置"的函数
提示:
使用confirm()确定框，来确认是否取消设置。
如是将以上所有的设置恢复原始值,否则不做操作。
六、当点击相应按钮，执行相应操作，为按钮添加相应事件

JS进阶：
第1章 系好安全带,准备启航
让你认识JS
你知道吗，Web前端开发师需要掌握什么技术?也许你已经了解HTML标记(也称为结构)，知道了CSS样式(也称为表示)，会使用HTML+CSS创建一个漂亮的页面，但这还不够，它只是静态页面而已。我们还需使用JavaScript增加行为，为网页添加动态效果。准备好，让JavaScript带你进入新境界吧!
JavaScript能做什么？
1.增强页面动态效果(如:下拉菜单、图片轮播、信息滚动等)
2.实现页面与用户之间的实时、动态交互(如:用户注册、登陆验证等)
JS进阶篇学习什么？
在JavaScript入门篇中，我们学习了如何插入JS、输出内容及简单的DOM操作，JavaScript进阶篇让您进一步的了解JS的变量、数组、函数、语法、对象、事件、DOM操作，制作简单的网页动态效果。
注意:
1. JS是区分大小写的，如：classname和ClassName是不一样的。同时注意方法、属性、变量等的大小写吆。
2. JS中的字符、符号等一定要在英文状态下输入吆。
review.html

编程练习
小伙伴们，实现在html页面中的插入JavaScript脚本，打开页面时，在页面中显示一句话 : "系好安全带,准备启航--目标JS"，并弹出一个提示框："准备好了，起航吧！"
温馨提示: 完成任务后，请验证是否与实践要求一致，如一致，恭喜您，已经掌握此技能。否则，请重新学习课程内容吆，直到实践编写代码与实践要求一致。
practice.html
script1.html

什么是变量
什么是变量? 从字面上看，变量是可变的量；从编程角度讲，变量是用于存储某种/某些数值的存储器。我们可以把变量看做一个盒子,盒子用来存放物品,物品可以是衣服、玩具、水果...等。

给变量取个名字(变量命名)
我们为了区分盒子，可以用BOX1,BOX2等名称代表不同盒子，BOX1就是盒子的名字（也就是变量的名字）。
我们赶快给变量取个好名字吧!变量名字可以任意取，只不过取名字要遵循一些规则:
1.必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。如下:
正确:
    mysum
    _mychar
    $numa1
错误:
  6num  //开头不能用数字
  %sum //开头不能用除(_ $)外特殊符号,如(%  + /等)
  sum+num //开头中间不能使用除(_ $)外特殊符号，如(%  + /等)
2.变量名区分大小写，如:A与a是两个不同变量。
3.不允许使用JavaScript关键字和保留字做变量名。
关键字
break else new var case finally return void catch for switch while default if throw delte in try do
instanceof typeof
保留字
abstract enum int short boolean export interface static byte extends logn super
char final native synchronized class float package throws const goto private throws debugger
implements protected volatile double import public
variable1.html

确定你的存在(变量声明)
我们要使用盒子装东西,是不是先要找到盒子,那在编程中，这个过程叫声明变量,找盒子的动作，如何表示：
声明变量语法: var 变量名;
var就相当于找盒子的动作，在JavaScript中是关键字（即保留字），这个关键字的作用是声明变量，并为"变量"准备位置(即内存）。
var mynum ; //声明一个变量mynum
当然，我们可以一次找一个盒子，也可以一次找多个盒子，所以Var还可以一次声明多个变量，变量之间用","逗号隔开。
var num1,mun2 ; //声明一个变量num1
注意:变量也可以不声明，直接使用，但为了规范，需要先声明，后使用。
declareVariable.html

多样化的我(变量赋值）
我们可以把变量看做一个盒子,盒子用来存放物品,那如何在变量中存储内容呢?
我们使用"="号给变量存储内容,看下面的语句:
var mynum = 5 ; //声明变量mynum并赋值。
这个语句怎么读呢？ 给变量mynum赋值，值为5。我们也可以这样写:
var mynum; //声明变量mynum
mynum = 5 ; //给变量mynum赋值
注:这里 "="号的作用是给变量赋值，不是等于号。
盒子可以装衣服、玩具、水果...等。其实，变量是无所不能的容器，你可以把任何东西存储在变量里，如数值、字符串、布尔值等，例如：
var num1 = 123;       // 123是数值
var num2 = "一二三";    //"一二三"是字符串
var num3 = true;    //布尔值true（真），false(假)
其中，num1变量存储的内容是数值；num2变量存储的内容是字符串，字符串需要用一对引号""括起来，num3变量存储的内容是布尔值(true、false)。

表达出你的想法(表达式)
表达式与数学中的定义相似，表达式是指具有一定的值、用操作符把常数和变量连接起来的代数式。一个表达式可以包含常数或变量。
我们先看看下面的JavaScript语句：
JavaScript语句
num = num + 1;
变量 赋值 表达式
生活中“再见”表达方法很多，如:英语(goodbye）、网络语（88）、肢体语（挥挥手）等。在JavaScript表达式无处不在，所以一定要知道可以表达哪些内容，看看下面几种情况:
串表达式
"I Love You," + mychar
编写串表达式，值为字符串
注意，串表达式中mychar是变量

数值表达式
num + 5*3
2 + 2.5
编写数值表达式，值为数值
注意，数值表达式中num是变量

布尔表达式
2 > 3
num == 5
num < 60
编写布尔值true或false的表达式
注意，布尔表达式中num是变量

我还有其它用途( +号操作符）
操作符是用于在JavaScript中指定一定动作的符号。
（1）操作符
看下面这段JavaScript代码。
sum = numa + numb;
其中的"="和"+"都是操作符。
JavaScript中还有很多这样的操作符，例如，算术操作符(+、-、*、/等)，比较操作符(<、>、>=、<=等)，逻辑操作符(&&、||、！)。
注意: “=” 操作符是赋值，不是等于。
(2) "+"操作符
算术运算符主要用来完成类似加减乘除的工作，在JavaScript中，“+”不只代表加法，还可以连接两个字符串，例如：
mystring = "Java" + "Script"; // mystring的值“JavaScript”这个字符串
+号两边是数值，功能为计算，值为数值。
+号两边一侧为字符串，功能为连接作用，值为字符串。
otherFunction.html

自加一，自减一 ( ++和- -)
算术操作符除了(+、-、*、/)外，还有两个非常常用的操作符，自加一“++”；自减一“--”。首先来看一个例子：
mynum = 10;
mynum++; //mynum的值变为11
mynum--; //mynum的值又变回10
上面的例子中，mynum++使mynum值在原基础上增加1，mynum--使mynum在原基础上减去1,其实也可以写成:
mynum = mynum + 1;//等同于mynum++
mynum = mynum - 1;//等同于mynum--
twoAorS.html

较量较量(比较操作符)
我们先来做道数学题，数学考试成绩中，小明考了90分，小红考了95分，问谁考的分数高?
答: 因为“95 > 90”，所以小红考试成绩高。
其中大于号">" 就是比较操作符，小红考试成绩和小明考试成绩就是操作数，并且是两个操作数。
也就是说两个操作数通过比较操作符进行比较，得到值为真（true）和假(false)。
在JavaScript中，这样的比较操作符有很多，这些操作符的含义如下:
操作符   描述
<       小于
>       大于
<=      小于或等于
>=      大于或等于
==      等于
!=      不等于
看看下面例子:
var a = 5;//定义a变量，赋值为5
var b = 9; //定义b变量，赋值为9
document.write(a < b); //a小于b的值吗? 结果是真(true)
document.write(a >= b); //a大于或等于b的值吗? 结果是假(false)
document.write(a != b); //a不等于b的值吗? 结果是真(true)
document.write(a == b); //a等于b的值吗? 结果是假(false)
实际上，JavaScript允许对任意数据类型做比较：
false == 0; // true
false === 0; // false
要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：
第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。
由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。
另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：
NaN === NaN; // false
唯一能判断NaN的方法是通过isNaN()函数：
isNaN(NaN); // true
最后要注意浮点数的相等比较：
1 / 3 === (1 - 2 / 3); // false
这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
compare.html

null和undefined
null表示一个“空”的值，它和0以及空字符串""不同，0是一个数值，""表示长度为0的字符串，而null表示“空”。
在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。
JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。
当a未定义时，判断a未定义
if(a == undefined)
if(typeof(a) == "undefined")

我与你同在(逻辑与操作符）
数学里面的“a>b”，在JavaScript中还表示为a>b；数学中的“b大于a，b小于c”是“a<b<c”，那么在JavaScript中可以用&&表示，如下：
b>a && b<c    //“&&”是并且的意思, 读法"b大于a"并且" b小于c "
好比我们参加高考时,在进入考场前,必须出示准考证和身份证,两者缺一不可，否则不能参加考试，表示如下:
if(有准考证 &&有身份证)
{
   进行考场考试
}
 “&&”是逻辑与操作符，只有“&&”两边值同时满足(同时为真)，整个表达式值才为真。
逻辑与操作符值表:
A                B                 A$$B
true            true               true
true            false              false
false           true               false
false           false              false
注意: 如果A为假，A && B为假，不会在执行B; 反之，如果A为真，要由 B 的值来决定 A && B 的值。
and.html

我或你都可以 (逻辑或操作符）
"||"逻辑或操作符，相当于生活中的“或者”，当两个条件中有任一个条件满足，“逻辑或”的运算结果就为“真”。
例如：本周我们计划出游,可是周一至周五工作,所以周六或者周日哪天去都可以。即两天中只要有一天有空，就可以出游了。
var a = 3;
var b = 5;
var c;
c = b > a || a> b;  //b>a是true，a>b是false，c是true
逻辑或操作符值表:
A                B                 A||B
true            true               true
true            false              true
false           true               true
false           false              false
注意: 如果A为真，A || B为真，不会在执行B; 反之，如果A为假，要由 B 的值来决定 A || B 的值。
or.html

是非颠倒(逻辑非操作符）
"!"是逻辑非操作符，也就是"不是"的意思,非真即假，非假即真。好比小华今天买了一个杯子，小明说:"杯子是白色的"，小亮说:“杯子是红色的”，小华说："小明说的不是真话，小亮说的不是假话"。猜猜小华买的什么颜色的杯子，答案：红色杯子。
逻辑非操作符值表:
A       !A
true    false
false   true
看看下面代码，变量c的值是什么:
var a = 3;
var b = 5;
var c;
c = ! (b > a);  // b>a值是true,!(b>a)值是false
c = ! (b < a);  // b<a值是false, !(b<a)值是true
not.html

保持先后顺序(操作符优先级）
我们都知道，除法、乘法等操作符的优先级比加法和减法高，例如：
var numa = 3;
var numb = 6
jq = numa + 30 / 2 - numb * 3;  // 结果为0
如果我们要改变运算顺序，需添加括号的方法来改变优先级:
var numa = 3;
var numb = 6
jq= ((numa + 30) / (2 - numb)) * 3; //结果是-24.75
操作符之间的优先级（高到低）:
算术操作符 → 比较操作符 → 逻辑操作符 → "="赋值符号
如果同级的运算是按从左到右次序进行,多层括号由里向外。
var numa = 3;
var numb = 6;
jq = numa + 30 > 10 && numb * 3 < 2;  //结果为false
level.html

练习：
考考大家的数学，计算以下计算公式的结果。然后在浏览器中运行一下，看看结果是否跟你的结果一致。
practice2.html

第3章 一起组团(数组)
一起组团（什么是数组）
我们知道变量用来存储数据，一个变量只能存储一个内容。假设你想存储10个人的姓名或者存储20个人的数学成绩，
就需要10个或20个变量来存储，如果需要存储更多数据，那就会变的更麻烦。我们用数组解决问题，
一个数组变量可以存放多个数据。好比一个团，团里有很多人，如下我们使用数组存储5个学生成绩。
数组是一个值的集合，每个值都有一个索引号，从0开始，每个索引都有一个相应的值，根据需要添加更多数值。
array/array.html

组团，并给团取个名（如何创建数组）
使用数组之前首先要创建，而且需要把数组本身赋至一个变量。好比我们出游，要组团，并给团定个名字“云南之旅”。
创建数组语法：
var myarray = new Array();
 我们创建数组的同时，还可以为数组指定长度，长度可任意指定。
var myarray = new Array(8); //创建数组，存储8个数据。
注意：
1.创建的新数组是空数组，没有值，如输出，则显示undefined。
2.虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度为8，仍然可以将元素存储在规定长度以外。
array/array2.html

谁是团里成员（数组赋值）
数组创建好，接下来我们为数组赋值。我们把数组看似旅游团的大巴车，大巴车里有很多位置，每个位置都有一个号码，顾客要坐在哪个位置呢？
第一步：组个大巴车
第二步：按票对号入座
        大巴车的1号座位是张三
        大巴车的2号座位是李四
数组的表达方式：
第一步：创建数组var myarr = new Array();
第二步：给数组赋值
        myarr[1] = " 张三";
        myarr[2] = " 李四";
下面创建一个数组，用于存储5个人的数学成绩。
var myarray = new Array(); //创建一个新的空数组
myarray[0] = 66; //存储第1个人的成绩
myarray[1] = 80; //存储第2个人的成绩
myarray[2] = 90; //存储第3个人的成绩
myarray[3] = 77; //存储第4个人的成绩
myarray[4] = 59; //存储第5个人的成绩
注意：数组每个值有一个索引号，从0开始。
我们还可以用简单的方法创建上面的数组和赋值：
第一种方法：
var myarray = new Array(66,80,90,77,59);//创建数组同时赋值
第二种方法：
 var myarray = [66,80,90,77,59];//直接输入一个数组（称 “字面量数组”）
然而，出于代码的可读性考虑，强烈建议直接使用[]。
注意：数组存储的数据可以是任何类型（数字、字符、布尔值等）
array/array3.html
<script language="javascript">等效于<script type="text/javascript">

团里添加新成员（向数组增加一个新元素）
上一节中，我们使用myarray变量存储了5个人的成绩，现在多出一个人的成绩，如何存储呢？
只需使用下一个未用的索引，任何时刻可以不断向数组增加新元素。
myarray[5] = 88; //使用一个新索引，为数组增加一个新元素
array/array4.html

呼叫团里成员(使用数组元素)
我们知道数组中的每个值有一个索引号，从0开始，如下图， myarray变量存储6个人的成绩：
要得到一个数组元素的值，只需引用数组变量并提供一个索引，如：
第一个人的成绩表示方法：myarray[0]
第三个人的成绩表示方法: myarray[2]
array/array5.html

了解成员数量(数组属性length)
如果我们想知道数组的大小，只需引用数组的一个属性length。Length属性表示数组的长度，即数组中元素的个数。
语法：
myarray.length; //获得数组myarray的长度
注意：因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。如数组的长度是5，数组的上下限分别是0和4。
var arr = [55,32,5,90,60,98,76,54];//包含8个数值的数组arr
document.write(arr.length); //显示数组长度8
document.write(arr[7]); //显示第8个元素的值54
同时，JavaScript数组的length属性是可变的，这一点需要特别注意。
arr.length = 10; //增大数组的长度
document.write(arr.length); //数组长度已经变为10
数组随元素的增加，长度也会改变，如下:
var arr = [98,76,54,56,76]; // 包含5个数值的数组
document.write(arr.length); //显示数组的长度5
arr[15] = 34;  //增加元素，使用索引为15,赋值为34
alert(arr.length); //显示数组的长度16                     x
array/array6.html

二维数组
一维数组，我们看成一组盒子，每个盒子只能放一个内容。
一维数组的表示: myarray[ ]
二维数组，我们看成一组盒子，不过每个盒子里还可以放多个盒子。
二维数组的表示: myarray[ ][ ]
注意: 二维数组的两个维度的索引值也是从0开始，两个维度的最后一个索引值为长度-1。
1. 二维数组的定义方法一
var myarr = new Array();  //先声明一维
for(var i = 0; i < 2; i++){   //一维长度为2
   myarr[i] = new Array();  //再声明二维
   for(var j = 0; j<3; j++){   //二维长度为3
   myarr[i][j] = i + j;   // 赋值，每个数组元素的值为i+j
   }
 }

注意: 关于for 循环语句，请看第四章4-5 。
2. 二维数组的定义方法二
var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]
3. 赋值
myarr[0][1] = 5; //将5的值传入到数组中，覆盖原有值。
说明: myarr[0][1] ,0 表示表的行，1表示表的列。
array/array7.html

编程练习
使用Javascript语言，把以下数组
   var  arr = ['*','##',"***","&&","****","##*"];
   arr[7] = "**";
在页面显示如下图所示的图案：
*
**
***
****
array/practice.html

对象：
JavaScript的对象是一组由键-值组成的无序集合，例如：
var person = {
    name: "Jef",
    age: 20,
    tags: ["js", "web", "mobile"],
    city: "Beijing",
    hasCar: true,
    zipcode: null
};
JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为"Bob"，zipcode属性为null。
JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。
要获取一个对象的属性，我们用对象变量.属性名的方式：

person.name; // "Jef"
person.zipcode; // null
访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用""括起来：
var xiaohong = {
    name: "小红",
    "middle-school": "No.1 Middle School"
};
xiaohong.name
"小红"
xiaohong["name"]
"小红"
xiaohong["middle-school"]
"No.1 Middle School"
如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined：
由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：
var xiaoming = {
    name: "小明"
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming["name"]; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：
var xiaoming = {
    name: "小明",
    birth: 1990,
    school: "No.1 Middle School",
    height: 1.70,
    weight: 65,
    score: null
};
undefined
name in xiaoming
false
"name" in xiaoming
true
"test" in xiaoming
false
"weight" in xiaoming
true
必须加上""，不然会返回false
不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：
"toString" in xiaoming
true
因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。
要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：
xiaoming.hasOwnProperty("toString")
false
xiaoming.hasOwnProperty("weight")
true

第4章 跟着我的节奏走(流程控制语句)
做判断（if语句）
if语句是基于条件成立才执行相应代码时使用的语句。
语法:
if(条件)
{ 条件成立时执行代码}
注意：if小写，大写字母（IF）会出错！
假设你应聘web前端技术开发岗位，如果你会HTML技术，你面试成功，欢迎加入公司。代码表示如下:
<script type="text/javascript">
  var mycarrer = "HTML";
  if (mycarrer == "HTML")
  {
    document.write("你面试成功，欢迎加入公司。");
  }
</script>
flowContrl/if.html

二选一 （if...else语句）
if...else语句是在指定的条件成立时执行代码，在条件不成立时执行else后的代码。
语法:
if(条件)
{ 条件成立时执行的代码}
else
{条件不成立时执行的代码}
假设你应聘web前端技术开发岗位，如果你会HTML技术，你面试成功，欢迎加入公司，否则你面试不成功，不能加入公司。
代码表示如下:
<script type="text/javascript">
  var mycarrer = "HTML"; //mycarrer变量存储技能
  if (mycarrer == "HTML")
    { document.write("你面试成功，欢迎加入公司。");  }
  else  //否则，技能不是HTML
    { document.write("你面试不成功，不能加入公司。");}
</script>
flowContrl/ifelse.html

多重判断（if..else嵌套语句）
要在多组语句中选择一组来执行，使用if..else嵌套语句。
语法:
if(条件1)
{ 条件1成立时执行的代码}
else  if(条件2)
{ 条件2成立时执行的代码}
...
else  if(条件n)
{ 条件n成立时执行的代码}
else
{ 条件1、2至n不成立时执行的代码}
假设数学考试，小明考了86分，给他做个评价，60分以下的不及格，60(包含60分)-75分为良好，75(包含75分)-85分为很好，85(包含85分)-100优秀。
flowControl/ifelseifelse.html

多种选择（Switch语句)
当有很多种选项的时候，switch比if else使用更方便。
语法:
switch(表达式)
{
case值1:
  执行代码块 1
  break;
case值2:
  执行代码块 2
  break;
...
case值n:
  执行代码块 n
  break;
default:
  与 case值1 、 case值2...case值n 不同时执行的代码
}
语法说明:
switch必须赋初始值，值与每个case值匹配。满足执行该 case 后的所有语句，并用break语句来阻止运行下一个case。如所有case值都不匹配，执行default后的语句。
假设评价学生的考试成绩，10分满分制，我们按照每一分一个等级将成绩分等，并根据成绩的等级做出不同的评价。
注意:记得在case所执行的语句后添加上一个break语句。否则就直接继续执行下面的case中的语句。
flowControl/switch.html

重复重复（for循环）
很多事情不只是做一次，要重复做。如打印10份试卷，每次打印一份，重复这个动作，直到打印完成。这些事情，我们使用循环语句来完成，循环语句，就是重复执行一段代码。
for语句结构：
for(初始化变量;循环条件;循环迭代)
{
    循环语句
 }
for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：
var x = 0;
for (;;) { // 将无限循环下去
    if (x > 100) {
        break; // 通过if判断来退出循环
    }
    x ++;
}
var o = {
    name: "Jack",
    age: 20,
    city: "Beijing"
};
for (var key in o) {
    alert(key + "" + o[key]);
}
要过滤掉对象继承的属性，用hasOwnProperty()来实现：
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        alert(key + "" + o[key]);
    }
}
由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引：
var a = ["A", "B", "C"];
for (var i in a) {
    alert(i); // "0", "1", "2"
    alert(a[i]); // "A", "B", "C"
}
请注意，for ... in对Array的循环得到的是String而不是Number。
假如，一个盒子里有6个球，我们每次取一个，重复从盒中取出球，直到球取完为止。

<script type="text/javascript">
var num = 1;
for (num=1; num <= 6; num++)  //初始化值；循环条件；循环后条件值更新
{   document.write("取出第" + num + "个球<br />");
}
</script>
flowControl/for.html

和for循环有相同功能的还有while循环, while循环重复执行一段代码，直到某个条件不再满足。

while语句结构：
while(判断条件)
{
    循环语句
 }
使用while循环，完成从盒子里取球的动作，每次取一个，共6个球。
<script type="text/javascript">
var num=0;  //初始化值
while (num <= 6)   //条件判断
{
  document.write("取出第" + num + "个球<br />");
  num = num + 1;  //条件值更新
}
</script>
flowControl/while.html

来来回回(do...while循环)
do while结构的基本原理和while结构是基本相同的，但是它保证循环体至少被执行一次。因为它是先执行代码，后判断条件，如果条件为真，继续循环。

do...while语句结构：
do
{
    循环语句
 }
while(判断条件)
我们试着输出5个数字。
<script type="text/javascript">
   num = 1;
   do
   {
     document.write("数值为:" +  num + "<br />");
     num++; //更新条件
   }
   while(num <= 5)
</script>
flowControl/dowhile.html

用do { ... } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。

退出循环break
在while、for、do...while、while循环中使用break语句退出当前循环，直接执行后面的代码。
格式如下：
for(初始条件;判断条件;循环后条件值更新)
{
  if(特殊情况)
  {break;}
  循环代码
}
当遇到特殊情况的时候，循环就会立即结束。看看下面的例子，输出10个数，如果数值为5，就停止输出。
注:当num=5的时候循环就会结束，不会输出后面循环的内容。
flowControl/break.html

继续循环continue
continue的作用是仅仅跳过本次循环，而整个循环体继续执行。
语句结构：
for(初始条件;判断条件;循环后条件值更新)
{
  if(特殊情况)
  { continue; }
 循环代码
}
上面的循环中，当特殊情况发生的时候，本次循环将被跳过，而后续的循环则不会受到影响。好比输出10个数字，如果数字为5就不输出了。
注:上面的代码中，num=5的那次循环将被跳过。
flowControl/continue.html

编程练习
在一个大学的编程选修课班里，我们得到了一组参加该班级的学生数据，分别是姓名、性别、年龄和年级，接下来呢，我们要利用JavaScript的知识挑出其中所有是大一的女生的的名字哦。
学生信息如下：
    ('小A','女',21,'大一'),  ('小B','男',23,'大三'),
    ('小C','男',24,'大四'),  ('小D','女',21,'大一'),
    ('小E','女',22,'大四'),  ('小F','男',21,'大一'),
    ('小G','女',22,'大二'),  ('小H','女',20,'大三'),
    ('小I','女',20,'大一'),  ('小J','男',20,'大三')
flowControl/practice.html

什么是函数
函数的作用，可以写一次代码，然后反复地重用这个代码。
如:我们要完成多组数和的功能。
var sum;
sum = 3 + 2;
alert(sum);
sum = 7 + 8 ;
alert(sum);
....  //不停重复两行代码
如果要实现8组数的和，就需要16行代码，实现的越多，代码行也就越多。所以我们可以把完成特定功能的代码块放到一个函数里，直接调用这个函数，就省去重复输入大量代码的麻烦。
使用函数完成:
function add2(a, b){
sum = a + b;
 alert(sum);
} //  只需写一次就可以

add2(3, 2);
add2(7, 8);
....  //只需调用函数就可以


定义函数
如何定义一个函数呢？看看下面的格式：
function  函数名( )
{
     函数体;
}
function定义函数的关键字，“函数名”你为函数取的名字，“函数体”替换为完成特定功能的代码。
我们完成对两个数求和并显示结果的功能。并给函数起个有意义的名字：“add2”，代码如下：
<script type="text/javascript">
  function add2(){
    sum = 3 + 2;
    alert(sum);
  }
  ​add2();
</script>
function/function1.html

函数调用
函数定义好后，是不能自动执行的，需要调用它,直接在需要的位置写函数名。

第一种情况:在<script>标签内调用。
  <script type="text/javascript">
    function add2(){
         sum = 1 + 1;
         alert(sum);
    }
  add2();//调用函数，直接写函数名。
</script>
第二种情况:在HTML文件中调用，如通过点击按钮后调用定义好的函数。

<html>
<head>
<script type="text/javascript">
   function add2(){
         sum = 5 + 6;
         alert(sum);
   }
</script>
</head>
<body>
<form>
<input type="button" value="click it" onclick="add2()">  //按钮,onclick点击事件，直接写函数名
</form>
</body>
</html>
注意:鼠标事件会在后面讲解。
function/function2.html

有参数的函数
上节中add2()函数不能实现任意指定两数相加。其实，定义函数还可以如下格式：
function 函数名(参数1, 参数2){
     函数代码
}
注意:参数可以多个，根据需要增减参数个数。参数之间用(逗号，）隔开。
按照这个格式，函数实现任意两个数的和应该写成：
function add2(x,y){
   sum = x + y;
   document.write(sum);
}
x和y则是函数的两个参数，调用函数的时候，我们可通过这两个参数把两个实际的加数传递给函数了。
例如，add2(3, 4)会求3+4的和，add2(60, 20)则会求出60和20的和。
function/function3.html

返回值的函数
思考:上一节函数中，通过"document.write"把结果输出来，如果想对函数的结果进行处理怎么办呢？
我们只要把"document.write(sum)"这行改成如下代码：
function add2(x,y){
   sum = x + y;
   return sum; //返回函数值,return后面的值叫做返回值。
}
还可以通过变量存储调用函数的返回值，代码如下:
result = add2(3, 4);//语句执行后,result变量中的值为7。
注意:函数中参数和返回值不只是数字，还可以是字符串等其它类型。
function/function4.html

编程练习
使用javascript代码写出一个函数：实现传入两个整数后弹出较大的整数。
function/practice.html

第6章 事件响应，让网页交互
JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。
比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。
主要事件列表：
事件            说明
onclick         鼠标点击事件
onmouseover     鼠标经过事件
onmouseout      鼠标移开事件
onchange        文本框内容改变事件
onselect        文本框内容选中事件
onfocus         光标聚集
onblur          光标离开
onload          网页导入
onunload        关闭网页

鼠标单击事件( onclick ）
onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。
比如，我们单击按钮时，触发 onclick 事件，并调用两个数和的函数add2()。代码如下：
<html>
<head>
   <script type="text/javascript">
      function add2(){
        var numa, numb, sum;
        numa = 6;
        numb = 8;
        sum = numa + numb;
        document.write("两数和为:" + sum);  }
   </script>
</head>
<body>
   <form>
      <input name="button" type="button" value="点击提交" onclick="add2()" />
   </form>
</body>
</html>
注意: 在网页中，如使用事件，就在该元素中设置事件属性。
event/event1.html

鼠标经过事件（onmouseover），感觉用处不大
鼠标经过事件，当鼠标移到一个对象上时，该对象就触发onmouseover事件，并执行onmouseover事件调用的程序。
现实鼠标经过"确定"按钮时，触发onmouseover事件，调用函数info()，弹出消息框，代码如下:
event/event2.html

鼠标移开事件（onmouseout）
鼠标移开事件，当鼠标移开当前对象时，执行onmouseout调用的程序。
当把鼠标移动到"登录"按钮上，然后再移开时，触发onmouseout事件，调用函数message()，代码如下:
event/event3.html

光标聚焦事件（onfocus）
当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。
如下代码, 当将光标移到文本框内时，即焦点在文本框内，触发onfocus 事件，并调用函数message()。
event/event4.html

失焦事件（onblur）
onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。
如下代码, 网页中有用户和密码两个文本框。当前光标在用户文本框内时（即焦点在文本框），在光标离开该文本框后（即失焦时），触发onblur事件，并调用函数message()。
event/event5.html

内容选中事件（onselect）
选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。
如下代码,当选中用户文本框内的文字时，触发onselect 事件，并调用函数message()。
event/event6.html

文本框内容改变事件（onchange）
通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。
如下代码,当用户将文本框内的文字改变后，弹出对话框“您改变了文本内容！”。
event/event7.html

加载事件（onload）
事件会在页面加载完成后，立即发生，同时执行被调用的程序。
注意：1. 加载页面时，触发onload事件，事件写在<body>标签内。

      2. 此节的加载页面，可理解为打开一个新页面时。
如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。
event/event8.html

卸载事件（onunload）
当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。
注意：不同浏览器对onunload事件支持不同。
如下代码,当退出页面时，弹出对话框“您确定离开该网页吗？”。
event/event9.html

编程练习
使用JS完成一个简单的计算器功能。实现2个输入框中输入整数后，点击第三个输入框能给出2个整数的加减乘除。

提示：获取元素的值设置和获取方法为：例：赋值：document.getElementById(“id”）.value = 1； 取值：var = document.getElementById(“id”）.value;
event/practice.html

JavaScript内置对象
什么是对象
JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。
对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等；
对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；
JavaScript 提供多个内建对象，比如 String、Date、Array 等等，使用对象前先定义，如下使用数组对象：
var objectName = new Array();//使用new关键字定义对象
或者
var objectName =[];
访问对象属性的语法:
objectName.propertyName
如使用 Array 对象的 length 属性来获得数组的长度：
var myarray = new Array(6);//定义数组对象
var myl = myarray.length;//访问数组长度length属性
以上代码执行后，myl的值将是：6
访问对象的方法：
objectName.methodName()
如使用string 对象的 toUpperCase() 方法来将文本转换为大写：
var mystr = "Hello world!";//创建一个字符串
var request = mystr.toUpperCase(); //使用字符串对象方法
以上代码执行后，request的值是：HELLO WORLD!
object/object1.html

Date 日期对象
日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）。
定义一个时间对象 :
var uDate = new Date();
注意:使用关键字new，Date()的首字母必须大写。
使 uDate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。
如果要自定义初始值，可以用以下方法：
var d = new Date(2012, 10, 1);  //2012年10月1日
var d = new Date('Oct 1, 2012'); //2012年10月1日
我们最好使用下面介绍的“方法”来严格定义时间。
访问方法语法：“<日期对象>.<方法>”
Date对象中处理时间和日期的常用方法：
方法名称            功能描述
get/setDate()       返回/设置日期
get/setFullYear()       返回/设置年份，用四位数表示
get/setYear()           返回/设置年份
get/setMonth()          返回/设置月份
get/setDay()            返回/设置星期几
0:一月.....11:十二月，所以加一
get/setHours()          返回/设置小时，24小时制
get/setMinutes()        返回/设置分钟数
get/setSeconds          返回/设置秒数
get/setMilliseconds     返回/设置毫秒数
get/setTime()           返回/设置时间（毫秒为单位）
注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。
如果要创建一个指定日期和时间的Date对象，可以用：
var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
你可能观察到了一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月……，所以要表示6月，我们传入的是5！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。
第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：
var d = Date.parse("2015-06-24T19:49:22.875+08:00");
d; // 1435146562875
但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date：
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)

时区：
Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：
var d = new Date(1435146562875);
d.toLocaleString(); // "2015/6/24 下午7:49:22"，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // "Wed, 24 Jun 2015 11:49:22 GMT"，UTC时间，与本地时间相差8小时
那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。
时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。
所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。
要获取当前时间戳，可以用：
if (Date.now) {
    alert(Date.now()); // 老版本IE没有now()方法
} else {
    alert(new Date().getTime());
}

返回/设置年份方法：
get/setFullYear() 返回/设置年份，用四位数表示。
var mydate = new Date();//当前时间2014年3月6日
document.write(mydate + "<br />");//输出当前时间
document.write(mydate.getFullYear() + "<br />");//输出当前年份
mydate.setFullYear(81); //设置年份
document.write(mydate + "<br />"); //输出年份被设定为 0081年。
注意:不同浏览器， mydate.setFullYear(81)结果不同，年份被设定为 0081或81两种情况。
结果:
Thu Mar 06 2014 10:57:47 GMT+0800
2014
Thu Mar 06 0081 10:57:47 GMT+0800
注意:
1.结果格式依次为：星期、月、日、年、时、分、秒、时区。(火狐浏览器)
2. 不同浏览器，时间格式有差异。
object/object2.html

返回星期方法：
getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下:
<script type="text/javascript">
  var mydate = new Date();//定义日期对象
  var weekday = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"];
//定义数组对象,给每个数组项赋值
  var mynum = mydate.getDay();//返回值存储在变量mynum中
  document.write(mydate.getDay());//输出getDay()获取值
  document.write("今天是："+ weekday[mynum]);//输出星期几
</script>
注意：以上代码是在2016年10月01日，星期六运行。
结果:
5
今天是：星期六
object/object3.html


返回/设置时间方法
get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。
如果将目前日期对象的时间推迟1小时，代码如下:
<script type="text/javascript">
  var mydate = new Date();
  document.write("当前时间：" + mydate + "<br />");
  mydate.setTime(mydate.getTime() + 60 * 60 * 1000);
  document.write("推迟一小时时间：" + mydate);
</script>
结果:
当前时间：Sat Oct 01 2016 20:22:20 GMT+0800 (中国标准时间)
推迟一小时时间：Sat Oct 01 2016 21:22:20 GMT+0800 (中国标准时间)
2. 时间推迟 1 小时,就是: “x.setTime(x.getTime() + 60 * 60 * 1000);”
object/object4.html

String 字符串对象
在之前的学习中已经使用字符串对象了，定义字符串的方法就是直接赋值。比如：
var mystr = "I love JavaScript!"
定义mystr字符串后，我们就可以访问它的属性和方法。
访问字符串对象的属性length:
stringObject.length; 返回该字符串的长度。
var mystr = "Hello World!";
var myl = mystr.length;
以上代码执行后，myl 的值将是：12
访问字符串对象的方法：
使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写：
var mystr = "Hello world!";
var mynum = mystr.toUpperCase();
以上代码执行后，mynum 的值是：HELLO WORLD!
任务
1.补充右边编辑器第8行，使用toLowerCase()方法，将字符串所有大写字母都变成小写的字符串。
2.字符串还有很多常用方法，快快进入下节学习字符串其它方法。
string/string1.html

返回指定位置的字符
charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。
语法:
stringObject.charAt(index)
参数说明：
index:必需。表示字符串中某个位置的数字，即字符在字符串中的下标。
注意：1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。
2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。
如:在字符串 "I love JavaScript!" 中，返回位置2的字符：
<script type="text/javascript">
  var mystr = "I love JavaScript!"
  document.write(mystr.charAt(2));
</script>
注意：一个空格也算一个字符。
以上代码的运行结果：
l
string/string2.html

返回指定的字符串首次出现的位置，JS中没有包含contains这一函数，可以使用str1.indexOf(str2) != -1的方式进行判断是否为空
indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
语法
stringObject.indexOf(substring, startpos)
参数说明：
参数          描述
substring    必需。规定要检索的字符串值
startpos   可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是0到stringObject.length-1。如省略改参数，则将从字符串的首字符开始检索。
说明：
1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。
2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。
3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。
注意：1.indexOf() 方法区分大小写。
2.如果要检索的字符串值没有出现，则该方法返回 -1。
例如: 对 "I love JavaScript!" 字符串内进行不同的检索：
<script type="text/javascript">
  var str = "I love JavaScript!"
  document.write(str.indexOf("I") + "<br />");
  document.write(str.indexOf("v") + "<br />");
  document.write(str.indexOf("v", 8));
</script>
以上代码的输出：
0
4
9
string/string4.html

字符串分割split()
知识讲解：
split() 方法将字符串分割为字符串数组，并返回此数组。
语法：
stringObject.split(separator, limit)
参数说明:
参数        描述
separator    必需。从该参数指定的地方分割stringObject。
limit           可选参数，分割的次数，如设置该参数，返回的子串不会多于这个参数指定的数组，若果五次参数未不限制次数。
注意：如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。
我们将按照不同的方式来分割字符串：
使用指定符号分割字符串，代码如下:
var mystr = "www.imooc.com";
document.write(mystr.split(".") + "<br />");
document.write(mystr.split(".", 2) + "<br />");
运行结果:
www,imooc,com
www,imooc
将字符串分割为字符，代码如下：
document.write(mystr.split("") + "<br />");
document.write(mystr.split("", 5));
运行结果:
w,w,w,.,i,m,o,o,c,.,c,o,m
w,w,w,.,i
string/string4.html

提取字符串substring()
substring() 方法用于提取字符串中介于两个指定下标之间的字符。
语法:
stringObject.substring(starPos, stopPos)
参数说明:
参数           描述
startPos        必需。一个非负的整数，开始位置。
stopPos          可选。一个非负的整数，结束位置，如果省略该参数，那么返回的子串会一直到字符串对象的结尾。
注意：
1. 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。
2. 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。
3. 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。
使用 substring() 从字符串中提取字符串，代码如下：
<script type = "text/javascript">
  var mystr = "I love JavaScript";
  document.write(mystr.substring(7));
  document.write(mystr.substring(2,6));
</script>
运行结果:
JavaScript
love
string/string5.html

提取指定数目的字符substr()
substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。
语法:
stringObject.substr(startPos, length)
参数说明:
参数      描述
startPos    必需。要提取的子串的起始位置。必须是数值。
length    可选。提取字符串的长度。如果省略，返回从stringObject的开始位置startPos到stringObject的结尾字符。
注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。
如果startPos为负数且绝对值大于字符串长度，startPos为0。
使用 substr() 从字符串中提取一些字符，代码如下：
<script type="text/javascript">
  var mystr = "I love JavaScript!";
  document.write(mystr.substr(7));
  document.write(mystr.substr(2,4));
</script>
运行结果：
JavaScript!
love
string/string6.html

Math对象
Math对象，提供对数据的数学计算。
使用 Math 的属性和方法，代码如下：
<script type="text/javascript">
  var mypi = Math.PI; 
  var myabs = Math.abs(-15);
  document.write(mypi);
  document.write(myabs);
</script>
运行结果:
3.141592653589793
15
注意：Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。
Math 对象属性
属性        说明
E       返回算数常量e，即自然对数的底数（约等于2.718）。
LN2     返回2的自然对数（约等于0.693）。
LN10    返回10的自然对数（约等于2.302）。
LOG2E   返回以2为底的e的对数（约等于1.442）。
LN10    返回以10为底的e的对数（约等于0.434）。
PI      返回圆周率（约等于3.14159）。
SQRT1_2 返回|返回2的平方根的倒数（约等于0.707）。
SQRT2   返回2的平方根（约等于1.414）。
Math 对象方法
属性        描述
abs(x)  返回数的绝对值。
acos(x) 返回数的反余弦值。
asin(x) 返回数的反正弦值。
atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。
atan2(y,x)  返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。
ceil(x) 对数进行上舍入。
cos(x)  返回数的余弦。
exp(x)  返回 e 的指数。
floor(x)  对数进行下舍入。
log(x)  返回数的自然对数（底为e）。
max(x,y)  返回 x 和 y 中的最高值。
min(x,y)  返回 x 和 y 中的最低值。
pow(x,y)  返回 x 的 y 次幂。
random()  返回 0 ~ 1 之间的随机数。
round(x)  把数四舍五入为最接近的整数。
sin(x)  返回数的正弦。
sqrt(x) 返回数的平方根。
tan(x)  返回角的正切。
toSource()  返回该对象的源代码。
valueOf() 返回 Math 对象的原始值。
以上方法不做全部讲解，只讲解部分方法。此节没有任务，快快进入下节学习。

向上取整ceil()
ceil() 方法可对一个数进行向上取整。
语法:
Math.ceil(x)
参数说明:
参数
注意：它返回的是大于或等于x，并且与x最接近的整数。
我们将把 ceil() 方法运用到不同的数字上，代码如下：
<script type="text/javascript">
  document.write(Math.ceil(0.8) + "<br />")
  document.write(Math.ceil(6.3) + "<br />")
  document.write(Math.ceil(5) + "<br />")
  document.write(Math.ceil(3.5) + "<br />")
  document.write(Math.ceil(-5.1) + "<br />")
  document.write(Math.ceil(-5.9))
</script>
运行结果：
1
7
5
4
-5
-5
math/math1.html

向下取整floor()
floor() 方法可对一个数进行向下取整。
语法:
Math.floor(x)
参数说明：
注意：返回的是小于或等于x，并且与 x 最接近的整数。
我们将在不同的数字上使用 floor() 方法，代码如下:
<script type="text/javascript">
  document.write(Math.floor(0.8) + "<br />")
  document.write(Math.floor(6.3) + "<br />")
  document.write(Math.floor(5) + "<br />")
  document.write(Math.floor(3.5) + "<br />")
  document.write(Math.floor(-5.1) + "<br />")
  document.write(Math.floor(-5.9))
</script>
运行结果：
0
6
5
3
-6
-6
math/math2.html

四舍五入round()
round() 方法可把一个数字四舍五入为最接近的整数。
语法:
Math.round(x)
参数说明：
注意：
1. 返回与 x 最接近的整数。
2. 对于 0.5，该方法将进行上舍入。(5.5 将舍入为 6)
3. 如果 x 与两侧整数同等接近，则结果接近 +∞方向的数字值 。(如 -5.5 将舍入为 -5; -5.52 将舍入为 -6),如下图:
把不同的数舍入为最接近的整数,代码如下：
<script type="text/javascript">
  document.write(Math.round(1.6) + "<br />");
  document.write(Math.round(2.5) + "<br />");
  document.write(Math.round(0.49) + "<br />");
  document.write(Math.round(-6.4) + "<br />");
  document.write(Math.round(-6.6));
</script>
运行结果：
2
3
0
-6
-7
math/math3.html

随机数 random()
random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。
语法：
Math.random();
注意：返回一个大于或等于 0 但小于 1 的符号为正的数字值。
我们取得介于 0 到 1 之间的一个随机数，代码如下：
<script type="text/javascript">
  document.write(Math.random());
</script>
运行结果：
0.190305486195328  
注意:因为是随机数，所以每次运行结果不一样，但是0 ~ 1的数值。
获得0 ~ 10之间的随机数，代码如下:
<script type="text/javascript">
  document.write((Math.random()) * 10);
</script>
运行结果：
8.72153625893887
math/math4.html

Array 数组对象
数组对象是一个对象的集合，里边的对象可以是不同类型的。数组的每一个成员对象都有一个“下标”，用来表示它在数组中的位置，是从零开始的
数组定义的方法：
1. 定义了一个空数组:
var  数组名= new Array();
2. 定义时指定有n个空元素的数组：
var 数组名 =new Array(n);
3.定义数组的时候，直接初始化数据：
var  数组名 = [<元素1>, <元素2>, <元素3>...];
我们定义myArray数组，并赋值，代码如下：
var myArray = [2, 8, 6]; 
说明：定义了一个数组 myArray，里边的元素是：myArray[0] = 2; myArray[1] = 8; myArray[2] = 6。
数组元素使用：
数组名[下标] = 值;
注意: 数组的下标用方括号括起来，从0开始。
数组属性：
length 用法：<数组对象>.length；返回：数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一。
数组方法：
方法  描述
concat()  连接两个或更多的数组，并返回结果。
join()  把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
push()  向数组的末尾添加一个或更多元素，并返回新的长度。
pop() 删除并返回数组的最后一个元素
var arr = [1, 2];
arr.push("A", "B"); // 返回Array新的长度: 4
arr; // [1, 2, "A", "B"]
arr.pop(); // pop()返回"B"
arr; // [1, 2, "A"]
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []
reverse() 颠倒数组中元素的顺序。
unshift() 向数组的开头添加一个或更多元素，并返回新的长度。
shift() 删除并返回数组的第一个元素
var arr = [1, 2];
arr.unshift("A", "B"); // 返回Array新的长度: 4
arr; // ["A", "B", 1, 2]
arr.shift(); // "A"
arr; // ["B", 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []
slice() 从某个已有的数组返回选定的元素
sort()  对数组的元素进行排序
它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：
splice()  删除元素，并向数组添加新元素。
splice(x, n, "", ""...)方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
toSource()  返回该对象的源代码。
toString()  把数组转换为字符串，并返回结果。
toLocaleString()  把数组转换为本地数组，并返回结果。
valueOf() 返回数组对象的原始值
以上方法不做全部讲解，只讲解部分方法。此节没有任务，快快进入下节学习。

数组连接concat()
concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。
语法
arrayObject.concat(array1,array2,...,arrayN)
参数说明：
参数      说明
array1     要连接的第一个数组
。。。。。。
arrayN      第N个数组
注意:  该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
我们创建一个数组，将把 concat() 中的参数连接到数组 myarr 中，代码如下：
<script type="text/javascript">
  var mya = new Array(3);
  mya[0] = "1";
  mya[1] = "2";
  mya[2] = "3";
  document.write(mya.concat(4,5)+"<br />");
  document.write(mya); 
</script>
运行结果：
1,2,3,4,5
1,2,3
我们创建了三个数组，然后使用 concat() 把它们连接起来，代码如下：
<script type="text/javascript">
  var mya1= new Array("hello!")
  var mya2= new Array("I","love");
  var mya3= new Array("JavaScript","!");
  var mya4=mya1.concat(mya2,mya3);
  document.write(mya4);
</script>
运行结果：
hello!,I,love,JavaScript,!
array/array8.html

指定分隔符连接数组元素join()
join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。
语法：
arrayObject.join(分隔符)
参数说明:
参数    描述
separator    可选。指定要使用的分隔符。如果省略该参数，则使用逗号进行分隔符。
注意：返回一个字符串，该字符串把数组中的各个元素串起来，用<分隔符>置于元素与元素之间。这个方法不影响数组原本的内容。 我们使用join（）方法，将数组的所有元素放入一个字符串中，代码如下：
<script type="text/javascript">
  var myarr = new Array(3);
  myarr[0] = "I";
  myarr[1] = "love";
  myarr[2] = "JavaScript";
  document.write(myarr.join());
</script>
运行结果：
I,love,JavaScript
我们将使用分隔符来分隔数组中的元素，代码如下：
<script type="text/javascript">
  var myarr = new Array(3)
  myarr[0] = "I";
  myarr[1] = "love";
  myarr[2] = "JavaScript";
  document.write(myarr.join("."));
</script>
运行结果：
I.love.JavaScript
array/array9.html

颠倒数组元素顺序reverse()
reverse() 方法用于颠倒数组中元素的顺序。
语法：
arrayObject.reverse()
注意：该方法会改变原来的数组，而不会创建新的数组。
定义数组myarr并赋值，然后颠倒其元素的顺序：
<script type="text/javascript">
  var myarr = new Array(3)
  myarr[0] = "1"
  myarr[1] = "2"
  myarr[2] = "3"
  document.write(myarr + "<br />")
  document.write(myarr.reverse())
</script>
运行结果：
1,2,3
3,2,1
array/array10.html

选定元素slice()
slice() 方法可从已有的数组中返回选定的元素。
语法
arrayObject.slice(start, end)
参数说明：
参数      描述
start      必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。
end        可选。规定从何处结束选取。该参数是数组片段借书处的数组下标。如果没有指定该参数，那么切分的数组包含从start到数组结束的所有元素。如果这个元素是负数，那么它规定的是从数组尾部开始算起的元素。
1.返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。
2. 该方法并不会修改数组，而是返回一个子数组。
注意：
1. 可使用负值从数组的尾部选取元素。
2.如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。
3. String.slice() 与 Array.slice() 相似。
我们将创建一个新数组，然后从其中选取的元素，代码如下：
<script type="text/javascript">
  var myarr = new Array(1, 2, 3, 4, 5, 6);
  document.write(myarr + "<br />");
  document.write(myarr.slice(2,4) + "<br />");
  document.write(myarr);
</script>
运行结果：
1,2,3,4,5,6
3,4
1,2,3,4,5,6
array/array11.html

数组排序sort()
sort()方法使数组中的元素按照一定的顺序排列。
排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。
通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。
语法:
arrayObject.sort(方法函数)
参数说明：
函数          描述
方法函数      可选。规定排序顺序。必须是函数。
1.如果不指定<方法函数>，则按unicode码顺序排列。
2.如果指定<方法函数>，则按<方法函数>所指定的排序方法排序。
myArray.sort(sortMethod);
注意: 该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 
  若返回值<=-1，则表示 A 在排序后的序列中出现在 B 之前。
  若返回值>-1 && <1，则表示 A 和 B 具有相同的排序顺序。
  若返回值>=1，则表示 A 在排序后的序列中出现在 B 之后。
1.使用sort()将数组进行排序，代码如下：
<script type="text/javascript">
  var myarr1 = new Array("Hello", "John", "love", "JavaScript"); 
  var myarr2 = new Array("80", "16", "50", "6", "100", "1");
  document.write(myarr1.sort() + "<br />");
  document.write(myarr2.sort());
</script>
运行结果：
Hello,JavaScript,John,love
1,100,16,50,6,80
注意:上面的代码没有按照数值的大小对数字进行排序。
2.如要实现这一点，就必须使用一个排序函数，代码如下：
<script type="text/javascript">
  function sortNum(a, b) {
  return a - b;
 //升序，如降序，把“a - b”该成“b - a”
}
 var myarr = new Array("80", "16", "50", "6", "100", "1");
  document.write(myarr + "<br />");
  document.write(myarr.sort(sortNum));
</script>
运行结果：
80,16,50,6,100,1
1,6,16,50,80,100
最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：
var a1 = ["B", "A", "C"];
var a2 = a1.sort();
a1; // ["A", "B", "C"]
a2; // ["A", "B", "C"]
a1 === a2; // true, a1和a2是同一对象
array/array12.html

编程练习
某班的成绩出来了，现在老师要把班级的成绩打印出来。
效果图:
XXXX年XX月X日 星期X--班级总分为:81
格式要求：
1、显示打印的日期。 格式为类似“XXXX年XX月XX日 星期X” 的当前的时间。
2、计算出该班级的平均分（保留整数）。
同学成绩数据如下：
"小明:87; 小花:81; 小红:97; 小天:76;小张:74;小小:94;小西:90;小伍:76;小迪:64;小曼:76"
任务
第一步：可通过javascript的日期对象来得到当前的日期。
提示:使用Date()日期对象，注意星期返回值为0-6，所以要转成文字"星期X"
第二步：一长窜的字符串不好弄，找规律后分割放到数组里更好操作哦。
步：分割字符串得到分数，然后求和取整。
提示：parseInt() 字符串类型转成整型。
array/pratice2.html

浏览器对象：
window对象
window对象是BOM的核心，window对象指当前的浏览器窗口。
window 对象属性
属性  描述
closed  返回窗口是否已被关闭。
defaultStatus 设置或返回窗口状态栏中的默认文本。
document  对 Document 对象的只读引用。请参阅 Document 对象。
history 对 History 对象的只读引用。请参数 History 对象。
innerheight 返回窗口的文档显示区的高度。
innerwidth  返回窗口的文档显示区的宽度。
length  设置或返回窗口中的框架数量。
location  用于窗口或框架的 Location 对象。请参阅 Location 对象。
name  设置或返回窗口的名称。
Navigator 对 Navigator 对象的只读引用。请参数 Navigator 对象。
opener  返回对创建此窗口的窗口的引用。
outerheight 返回窗口的外部高度。
outerwidth  返回窗口的外部宽度。
pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。
pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。
parent  返回父窗口。
Screen  对 Screen 对象的只读引用。请参数 Screen 对象。
self  返回对当前窗口的引用。等价于 Window 属性。
status  设置窗口状态栏的文本。
top 返回最顶层的先辈窗口。
window  window 属性等价于 self 属性，它包含了对窗口自身的引用。
screenLeft
screenTop
screenX
screenY
只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY。
window 对象方法
方法  描述
alert() 显示带有一段消息和一个确认按钮的警告框。
blur()  把键盘焦点从顶层窗口移开。
clearInterval() 取消由 setInterval() 设置的 timeout。
clearTimeout()  取消由 setTimeout() 方法设置的 timeout。
close() 关闭浏览器窗口。
confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。
createPopup() 创建一个 pop-up 窗口。
focus() 把键盘焦点给予一个窗口。
moveBy()  可相对窗口的当前坐标把它移动指定的像素。
moveTo()  把窗口的左上角移动到一个指定的坐标。
open()  打开一个新的浏览器窗口或查找一个已命名的窗口。
print() 打印当前窗口的内容。
prompt()  显示可提示用户输入的对话框。
resizeBy()  按照指定的像素调整窗口的大小。
resizeTo()  把窗口的大小调整到指定的宽度和高度。
scrollBy()  按照指定的像素值来滚动内容。
scrollTo()  把内容滚动到指定的坐标。
setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。
setTimeout()  在指定的毫秒数后调用函数或计算表达式。
注意:在JavaScript基础篇中，已讲解了部分属性，window对象重点讲解计时器。
browserObject/browserObject1.html

JavaScript 计时器
在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。
计时器类型：
一次性计时器：仅在指定的延迟时间之后触发一次。
间隔性触发计时器：每隔一定的时间间隔就触发一次。
计时器方法：
方法                说明
setTimeout()         指定的延迟时间之后来执行代码
dearTimeout()        取消setTimeout()的设置
setInterval()        每隔指定的时间执行代码        
dearInterval()       取消setInterval()设置

计时器setInterval()
在执行时,从载入页面后每隔指定的时间执行代码。
语法:
setInterval(代码, 交互时间);
参数说明：
1. 代码：要调用的函数或要执行的代码串。
2. 交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。
返回值:
一个可以传递给 clearInterval() 从而取消对"代码"的周期性执行的值。
调用函数格式(假设有一个clock()函数):
setInterval("clock()", 1000)
或
setInterval(clock, 1000)
我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下:
<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>计时器</title>
<script type="text/javascript">
  var int = setInterval(clock, 100)
  function clock(){
    var time = new Date();
    document.getElementById("clock").value = time;
  }
</script>
</head>
<body>
  <form>
    <input type="text" id="clock" size="50" />
  </form>
</body>
</html>
browserObject/browserObject2.html

取消计时器clearInterval()
clearInterval() 方法可取消由 setInterval() 设置的交互时间。
语法：
clearInterval(id_of_setInterval)
参数说明:
id_of_setInterval：由 setInterval() 返回的 ID 值。
每隔 100 毫秒调用 clock() 函数,并显示时间。当点击按钮时，停止时间，代码如下:
<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>计时器</title>
<script type="text/javascript">
   function clock(){
      var time = new Date();                     
      document.getElementById("clock").value = time;
   }
// 每隔100毫秒调用clock函数，并将返回值赋值给i
     var i = setInterval("clock()", 100);
</script>
</head>
<body>
  <form>
    <input type="text" id="clock" size="50" />
    <input type="button" value="Stop" onclick="clearInterval(i)" />
  </form>
</body>
</html>
browserObject/browserObject3.html

计时器setTimeout()
setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。
语法:
setTimeout(代码, 延迟时间);
参数说明：
1. 要调用的函数或要执行的代码串。
2. 延时时间：在执行代码前需等待的时间，以毫秒为单位（1s=1000ms)。
当我们打开网页3秒后，在弹出一个提示框，代码如下:
<!DOCTYPE HTML>
<html>
<head>
<script type="text/javascript">
  setTimeout("alert('Hello!')", 3000);
</script>
</head>
<body>
</body>
</html>
当按钮start被点击时，setTimeout()调用函数，在5秒后弹出一个提示框。
<!DOCTYPE HTML>
<html>
<head>
<script type="text/javascript">
function tinfo(){
  var t = setTimeout("alert('Hello!')", 5000);
 }
</script>
</head>
<body>
<form>
  <input type="button" value="start" onClick="tinfo()">
</form>
</body>
</html>
要创建一个运行于无穷循环中的计数器，我们需要编写一个函数来调用其自身。在下面的代码，当按钮被点击后，输入域便从0开始计数。
<!DOCTYPE HTML>
<html>
<head>
<script type="text/javascript">
var num=0;
function numCount(){
 document.getElementById('txt').value = num;
 num=num+1;
 setTimeout("numCount()", 1000);
 }
</script>
</head>
<body>
<form>
<input type="text" id="txt" />
<input type="button" value="Start" onClick="numCount()" />
</form>
</body>
</html>
browserObject/browserObject4.html

取消计时器clearTimeout()
setTimeout()和clearTimeout()一起使用，停止计时器。
语法:
clearTimeout(id_of_setTimeout)
参数说明:
id_of_setTimeout：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。
下面的例子和上节的无穷循环的例子相似。唯一不同是，现在我们添加了一个 "Stop" 按钮来停止这个计数器：
<!DOCTYPE HTML>
<html>
<head>
<script type="text/javascript">
  var num = 0, i;
  function timedCount(){
    document.getElementById('txt').value = num;
    num = num+1;
    i = setTimeout(timedCount, 1000);
  }
    setTimeout(timedCount, 1000);
  function stopCount(){
    clearTimeout(i);
  }
</script>
</head>
<body>
  <form>
    <input type="text" id="txt">
    <input type="button" value="Stop" onClick="stopCount()">
  </form>
</body>
</html>
browserObject/browserObject5.html

History 对象
history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。
注意:从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。
语法：
window.history.[属性|方法]
注意：window可以省略。
History 对象属性
属性  描述
length  返回浏览器历史列表中的 URL 数量。
History 对象方法
方法  描述
back()  加载 history 列表中的前一个 URL。
forward() 加载 history 列表中的下一个 URL。
go()  加载 history 列表中的某个具体页面。
使用length属性，当前窗口的浏览历史总长度，代码如下：
<script type="text/javascript">
  var HL = window.history.length;
  document.write(HL);
</script>
browserObject/browserObject6.html

返回前一个浏览的页面
back()方法，加载 history 列表中的前一个 URL。
语法：
window.history.back();
比如，返回前一个浏览的页面，代码如下：
window.history.back();
注意：等同于点击浏览器的倒退按钮。
back()相当于go(-1),代码如下:
window.history.go(-1);
browserObject/browserObject7.html

返回下一个浏览的页面
forward()方法，加载 history 列表中的下一个 URL。
如果倒退之后，再想回到倒退之前浏览的页面，则可以使用forward()方法,代码如下:
window.history.forward();
注意：等价点击前进按钮。
forward()相当于go(1),代码如下:
window.history.go(1);
browserObject/browserObject8.html

返回浏览历史中的其他页面
go()方法，根据当前所处的页面，加载 history 列表中的某个具体的页面。
语法：
window.history.go(number);
参数：
number    参数说明
1         前一个，go(1)等价于forward()
0         当前页面
-1        后一个，go(-1)等价back()
其他数值  要访问的URL在History的URL列表中的相对位置
浏览器中，返回当前页面之前浏览过的第二个历史页面，代码如下：
window.history.go(-2);
注意：和在浏览器中单击两次后退按钮操作一样。
同理，返回当前页面之后浏览过的第三个历史页面，代码如下：
window.history.go(3);
browserObject/browserObject9.html

Location对象
location用于获取或设置窗体的URL，并且可以用于解析URL。
语法:
location.[属性|方法]
location对象属性图示:
Location 对象属性
属性  描述
hash  设置或返回从井号 (#) 开始的 URL（锚）。
host  设置或返回主机名和当前 URL 的端口号。
hostname  设置或返回当前 URL 的主机名。
href  设置或返回完整的 URL。
pathname  设置或返回当前 URL 的路径部分。
port  设置或返回当前 URL 的端口号。
protocol  设置或返回当前 URL 的协议。
search  设置或返回从问号 (?) 开始的 URL（查询部分）。
Location 对象方法
属性  描述
assign()  加载新的文档。
reload()  重新加载当前文档。
replace() 用新的文档替换当前文档。
browserObject/browserObject10.html

Navigator对象
Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。
Navigator 对象属性
属性  描述
appCodeName 返回浏览器的代码名。
appMinorVersion 返回浏览器的次级版本。
appName 返回浏览器的名称。
appVersion  返回浏览器的平台和版本信息。
browserLanguage 返回当前浏览器的语言。
cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。
cpuClass  返回浏览器系统的 CPU 等级。
onLine  返回指明系统是否处于脱机模式的布尔值。
platform  返回运行浏览器的操作系统平台。
systemLanguage  返回 OS 使用的默认语言。
userAgent 返回由客户机发送服务器的 user-agent 头部的值。
userLanguage  返回 OS 的自然语言设置。
查看浏览器的名称和版本，代码如下:
<script type="text/javascript">
   var browser = navigator.appName;
   var b_version = navigator.appVersion;
   document.write("Browser name" + browser);
   document.write("<br />");
   document.write("Browser version" + b_version);
</script>
browserObject/browserObject11.html

userAgent
返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)
语法
navigator.userAgent
几种浏览的user_agent.，像360的兼容模式用的是IE、极速模式用的是chrom的内核。
使用userAgent判断使用的是什么浏览器(假设使用的是IE8浏览器),代码如下:
function validB(){ 
  var u_agent = navigator.userAgent; 
  var B_name = "Failed to identify the browser"; 
  if(u_agent.indexOf("Firefox") > -1){ 
      B_name = "Firefox"; 
  }else if(u_agent.indexOf("Chrome") > -1){ 
      B_name = "Chrome"; 
  }else if(u_agent.indexOf("MSIE") > -1 && u_agent.indexOf("Trident") > -1){ 
      B_name = "IE(8-10)";  
  }
    document.write("B_name:" + B_name + "<br />");
    document.write("u_agent:" + u_agent + "<br />"); 
} 
运行结果:
browserObject/browserObject12.html

screen对象
screen对象用于获取用户的屏幕信息。
语法：
window.screen.属性
Screen 对象属性
属性  描述
availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)。
availWidth  返回显示屏幕的宽度 (除 Windows 任务栏之外)。
bufferDepth 设置或返回调色板的比特深度。
colorDepth  返回目标设备或缓冲器上的调色板的比特深度。
deviceXDPI  返回显示屏幕的每英寸水平点数。
deviceYDPI  返回显示屏幕的每英寸垂直点数。
fontSmoothingEnabled  返回用户是否在显示控制面板中启用了字体平滑。
height  返回显示屏幕的高度。
logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数。
logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数。
pixelDepth  返回显示屏幕的颜色分辨率（比特每像素）。
updateInterval  设置或返回屏幕的刷新率。
width 返回显示器屏幕的宽度。

屏幕分辨率的高和宽
window.screen 对象包含有关用户屏幕的信息。
1. screen.height 返回屏幕分辨率的高
2. screen.width 返回屏幕分辨率的宽
注意:
1.单位以像素计。
2. window.screen 对象在编写时可以不使用 window 这个前缀。
我们来获取屏幕的高和宽，代码如下:
<script type="text/javascript">
  document.write( "屏幕宽度：" + screen.width + "px<br />" );
  document.write( "屏幕高度：" + screen.height + "px<br />" );
</script>
browserObject/browserObject13.html

屏幕可用高和宽度
1. screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如任务栏。
2. screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如任务栏。
注意:
不同系统的任务栏默认高度不一样，及任务栏的位置可在屏幕上下左右任何位置，所以有可能可用宽度和高度不一样。
我们来获取屏幕的可用高和宽度，代码如下：
<script type="text/javascript">
document.write("可用宽度：" + screen.availWidth);
document.write("可用高度：" + screen.availHeight);
</script>
注意:根据屏幕的不同显示值不同。
browserObject/browserObject14.html

编程练习
制作一个跳转提示页面：
要求：
1. 如果打开该页面后，如果不做任何操作则5秒后自动跳转到一个新的地址，如慕课网主页。
2. 如果点击“返回”按钮则返回前一个页面。
browserObject/pratice.html

认识DOM
文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。
HTML文档可以说由节点构成的集合，DOM节点有:
1. 元素节点：上图中<html>、<body>、<p>等都是元素节点，即标签。
2. 文本节点:向用户展示的内容，如<li>...</li>中的JavaScript、DOM、CSS等文本。
3. 属性节点:元素属性，如<a>标签的链接属性href="http://www.imooc.com"。
属性和方法：
下面的属性和方法可用于所有 HTML 元素上：
属性 / 方法 描述
element.accessKey 设置或返回元素的快捷键。
element.appendChild() 向元素添加新的子节点，作为最后一个子节点。
element.attributes  返回元素属性的 NamedNodeMap。
element.childNodes  返回元素子节点的 NodeList。
element.className 设置或返回元素的 class 属性。
element.clientHeight  返回元素的可见高度。
element.clientWidth 返回元素的可见宽度。
element.cloneNode() 克隆元素。
element.compareDocumentPosition() 比较两个元素的文档位置。
element.contentEditable 设置或返回元素的文本方向。
element.dir 设置或返回元素的文本方向。
element.firstChild  返回元素的首个子。
element.getAttribute()  返回元素节点的指定属性值。
element.getAttributeNode()  返回指定的属性节点。
element.getElementsByTagName()  返回拥有指定标签名的所有子元素的集合。
element.getFeature()  返回实现了指定特性的 API 的某个对象。
element.getUserData() 返回关联元素上键的对象。
element.hasAttribute()  如果元素拥有指定属性，则返回true，否则返回 false。
element.hasAttributes() 如果元素拥有属性，则返回 true，否则返回 false。
element.hasChildNodes() 如果元素拥有子节点，则返回 true，否则 false。
element.id  设置或返回元素的 id。
element.innerHTML 设置或返回元素的内容。
element.insertBefore()  在指定的已有的子节点之前插入新节点。
element.isContentEditable 设置或返回元素的内容。
element.isDefaultNamespace()  如果指定的 namespaceURI 是默认的，则返回 true，否则返回 false。
element.isEqualNode() 检查两个元素是否相等。
element.isSameNode()  检查两个元素是否是相同的节点。
element.isSupported() 如果元素支持指定特性，则返回 true。
element.lang  设置或返回元素的语言代码。
element.lastChild 返回元素的最后一个子元素。
element.namespaceURI  返回元素的 namespace URI。
element.nextSibling 返回位于相同节点树层级的下一个节点。
element.nodeName  返回元素的名称。
element.nodeType  返回元素的节点类型。
element.nodeValue 设置或返回元素值。
element.normalize() 合并元素中相邻的文本节点，并移除空的文本节点。
element.offsetHeight  返回元素的高度。
element.offsetWidth 返回元素的宽度。
element.offsetLeft  返回元素的水平偏移位置。
element.offsetParent  返回元素的偏移容器。
element.offsetTop 返回元素的垂直偏移位置。
element.ownerDocument 返回元素的根元素（文档对象）。
element.parentNode  返回元素的父节点。
element.previousSibling 返回位于相同节点树层级的前一个元素。
element.removeAttribute() 从元素中移除指定属性。
element.removeAttributeNode() 移除指定的属性节点，并返回被移除的节点。
element.removeChild() 从元素中移除子节点。
element.replaceChild()  替换元素中的子节点。
element.scrollHeight  返回元素的整体高度。
element.scrollLeft  返回元素左边缘与视图之间的距离。
element.scrollTop 返回元素上边缘与视图之间的距离。
element.scrollWidth 返回元素的整体宽度。
element.setAttribute()  把指定属性设置或更改为指定值。
element.setAttributeNode()  设置或更改指定属性节点。
element.setIdAttribute()  
element.setIdAttributeNode()  
element.setUserData() 把对象关联到元素上的键。
element.style 设置或返回元素的 style 属性。
element.tabIndex  设置或返回元素的 tab 键控制次序。
element.tagName 返回元素的标签名。
element.textContent 设置或返回节点及其后代的文本内容。
element.title 设置或返回元素的 title 属性。
element.toString()  把元素转换为字符串。
nodelist.item() 返回 NodeList 中位于指定下标的节点。
nodelist.length 返回 NodeList 中的节点数。
方法       说明
createElement(element)    创建一个新的元素节点
createTextNode()          创建一个包含着给定文本的新文本节点
dom/dom1.html

getElementsByName()方法
返回带有指定名称的节点对象的集合。
语法：
document.getElementsByName(name)
与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性。
注意:
1. 因为文档中的 name 属性可能不唯一，所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。
2. 和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。
dom/dom2.html

getElementsByTagName()方法
返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。
语法:
document.getElementsByTagName(Tagname)
说明:
1. Tagname是标签的名称，如p、a、img等标签名。
2. 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。
看看下面代码，通过getElementsByTagName()获取节点。
dom/dom3.html

区别getElementByID,getElementsByName,getElementsByTagName
以人来举例说明，人有能标识身份的身份证，有姓名，有类别(大人、小孩、老人)等。
1. ID 是一个人的身份证号码，是唯一的。所以通过getElementById获取的是指定的一个人。
2. Name 是他的名字，可以重复。所以通过getElementsByName获取名字相同的人集合。
3. TagName可看似某类，getElementsByTagName获取相同类的人集合。如获取小孩这类人，getElementsByTagName("小孩")。
把上面的例子转换到HTML中，如下:
<input type="checkbox" name="hobby" id="hobby1">  音乐
input标签就像人的类别。
name属性就像人的姓名。
id属性就像人的身份证。
方法总结如下:
方法         说明                获得
getElementById   通过制定id获得元素  一个
getElementsByName   通过元素名称 name 属性获得元素       一组
getElementsByTagName      通过标签名称获得元素          一组
注意：方法区分大小写
通过下面的例子(6个name="hobby"的复选项，两个按钮)来区分三种方法的不同:
  <input type="checkbox" name="hobby" id="hobby1">  音乐
  <input type="checkbox" name="hobby" id="hobby2">  登山
  <input type="checkbox" name="hobby" id="hobby3">  游泳
  <input type="checkbox" name="hobby" id="hobby4">  阅读
  <input type="checkbox" name="hobby" id="hobby5">  打球
  <input type="checkbox" name="hobby" id="hobby6">  跑步 
  <input type="button" value = "全选" id="button1">
  <input type="button" value = "全不选" id="button1">
1. document.getElementsByTagName("input")，结果为获取所有标签为input的元素，共8个。
2. document.getElementsByName("hobby")，结果为获取属性name="hobby"的元素，共6个。
3. document.getElementById("hobby6")，结果为获取属性id="hobby6"的元素，只有一个，"跑步"这个复选项。
dom/dom4.html

getAttribute()方法
通过元素节点的属性名称获取属性的值。
语法：
elementNode.getAttribute(name)
说明:
1. elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。
2. name：要想查询的元素节点的属性名字
看看下面的代码，获取h1标签的属性值：
dom/dom5.html

setAttribute()方法
setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。
语法：
elementNode.setAttribute(name, value)
说明：
1.name: 要设置的属性名。
2.value: 要设置的属性值。
注意：
1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。
2.类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。
dom/dom6.html

节点属性
在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：
1. nodeName : 节点的名称
2. nodeValue ：节点的值
3. nodeType ：节点的类型
一、nodeName 属性: 节点的名称，是只读的。
1. 元素节点的 nodeName 与标签名相同
2. 属性节点的 nodeName 是属性的名称
3. 文本节点的 nodeName 永远是 #text
4. 文档节点的 nodeName 永远是 #document
二、nodeValue 属性：节点的值
1. 元素节点的 nodeValue 是 undefined 或 null
2. 文本节点的 nodeValue 是文本自身
3. 属性节点的 nodeValue 是属性的值
三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:
元素类型    节点类型
  元素          1
  属性          2
  文本          3
  注释          8
  文档          9
dom/dom7.html

访问子结点childNodes
访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。
语法：
elementNode.childNodes
注意：
如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。
我们来看看下面的代码:
运行结果:
IE:
  UL子节点个数:3
  节点类型:1
其它浏览器:
   UL子节点个数:7
   节点类型:3
注意:
1. IE全系列、firefox、chrome、opera、safari兼容问题
2. 节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7，如下图所示:
如果把代码改成这样:
<ul><li>javascript</li><li>jQuery</li><li>PHP</li></ul>
运行结果:（IE和其它浏览器结果是一样的）
  UL子节点个数:3
  节点类型:1
dom/dom8.html

访问子结点的第一和最后项
一、firstChild 属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。
语法：
node.firstChild
说明：与elementNode.childNodes[0]是同样的效果。 
二、 lastChild 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。
语法：
node.lastChild
说明：与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 
注意: 上一节中，我们知道Internet Explorer 会忽略节点之间生成的空白文本节点，而其它浏览器不会。我们可以通过检测节点类型，过滤子节点。 (以后章节讲解)
dom/dom9.html

访问父节点parentNode
获取指定节点的父节点
语法：
elementNode.parentNode
注意:父节点只能有一个。
看看下面的例子,获取 P 节点的父节点，代码如下:
<div id="text">
  <p id="con"> parentNode 获取指点节点的父节点</p>
</div> 
<script type="text/javascript">
  var mynode = document.getElementById("con");
  document.write(mynode.parentNode.nodeName);
</script>
运行结果:
parentNode 获取指点节点的父节点
DIV
访问祖节点:
elementNode.parentNode.parentNode
看看下面的代码:
<div id="text">  
  <p>
    parentNode      
    <span id="con"> 获取指点节点的父节点</span>
  </p>
</div> 
<script type="text/javascript">
  var mynode= document.getElementById("con");
  document.write(mynode.parentNode.parentNode.nodeName);
</script>
运行结果:
parentNode获取指点节点的父节点
DIV
注意: 浏览器兼容问题，chrome、firefox等浏览器标签之间的空白也算是一个文本节点。
dom/dom10.html

访问兄弟节点
1. nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。
语法：
nodeObject.nextSibling
说明：如果无此节点，则该属性返回 null。
2. previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。
语法：
nodeObject.previousSibling  
说明：如果无此节点，则该属性返回 null。
注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。
解决问题方法:
判断节点nodeType是否为1, 如是为元素节点，跳过。
dom/dom11.html

插入节点appendChild()
在指定节点的最后一个子节点列表之后添加一个新的子节点。
语法:
appendChild(newnode)
参数:
newnode：指定追加的节点。
我们来看看，div标签内创建一个新的 P 标签，代码如下:
运行结果:
HTML
JavaScript
This is a new p
dom/dom12.html

插入节点insertBefore()
insertBefore() 方法可在已有的子节点前插入一个新的子节点。
语法:
insertBefore(newnode, node);
参数:
newnode: 要插入的新节点。
node: 指定此节点前插入节点。
我们在来看看下面代码，在指定节点前插入节点。
运行结果:
This is a new p
JavaScript
HTML
注意: otest.insertBefore(newnode,node); 也可以改为:  otest.insertBefore(newnode,otest.childNodes[0]); 
dom/dom13.html

删除节点removeChild()
removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。
语法:
nodeObject.removeChild(node)
参数:
node ：必需，指定需要删除的节点。
我们来看看下面代码，删除子点。
运行结果:
HTML
删除节点的内容: javascript
注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。
如果要完全删除对象，给 x 赋 null 值，代码如下:
dom/dom14.html

替换元素节点replaceChild()
replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 
语法：
node.replaceChild (newnode, oldnew ) 
参数：
newnode : 必需，用于替换 oldnew 的对象。 
oldnew : 必需，被 newnode 替换的对象。
我们来看看下面的代码:
效果: 将文档中的 Java 改为 JavaScript。
注意: 
1. 当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 
2. newnode 必须先被建立。 
dom/dom15.html

创建元素节点createElement
createElement()方法可创建元素节点。此方法可返回一个 Element 对象。
语法：
document.createElement(tagName)
参数:
tagName：字符串值，这个字符串用来指明创建元素的类型。
注意：要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。
我们来创建一个按钮，代码如下：
<script type="text/javascript">
   var body = document.body; 
   var input = document.createElement("input");  
   input.type = "button";  
   input.value = "创建一个按钮";  
   body.appendChild(input);  
 </script>  
效果：在HTML文档中，创建一个按钮。
我们也可以使用setAttribute来设置属性，代码如下：
<script type="text/javascript">  
   var body= document.body;             
   var btn = document.createElement("input");  
   btn.setAttribute("type", "text");  
   btn.setAttribute("name", "q");  
   btn.setAttribute("value", "使用setAttribute");  
   btn.setAttribute("onclick", "javascript:alert('This is a text!');");       
   body.appendChild(btn);  
</script>  
效果：在HTML文档中，创建一个文本框，使用setAttribute设置属性值。 当点击这个文本框时，会弹出对话框“This is a text!”。
dom/dom16.html

创建文本节点createTextNode
createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。
语法：
document.createTextNode(data)
参数：
data : 字符串值，可规定此节点的文本。
我们来创建一个<div>元素并向其中添加一条消息，代码如下：
dom/dom17.html

浏览器窗口可视区域大小
获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法:
一、对于IE9+、Chrome、Firefox、Opera 以及 Safari：
•  window.innerHeight - 浏览器窗口的内部高度
•  window.innerWidth - 浏览器窗口的内部宽度
二、对于 Internet Explorer 8、7、6、5：
•  document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。
•  document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。
或者
Document对象的body属性对应HTML文档的<body>标签
•  document.body.clientHeight
•  document.body.clientWidth
在不同浏览器都实用的 JavaScript 方案：
var w = document.documentElement.clientWidth
      || document.body.clientWidth;
var h = document.documentElement.clientHeight
      || document.body.clientHeight
dom/dom18.html

网页尺寸scrollHeight
scrollHeight和scrollWidth，获取网页内容高度和宽度。
一、针对IE、Opera:
scrollHeight 是网页内容实际高度，可以小于 clientHeight。
二、针对NS、FF:
scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。
三、浏览器兼容性
var w =document.documentElement.scrollWidth
   || document.body.scrollWidth;
var h =document.documentElement.scrollHeight
   || document.body.scrollHeight;
注意:区分大小写
scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。
dom/dom19.html

网页尺寸offsetHeight
offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。
一、值
offsetHeight = clientHeight + 滚动条 + 边框。
二、浏览器兼容性
var w = document.documentElement.offsetWidth
    || document.body.offsetWidth;
var h = document.documentElement.offsetHeight
    || document.body.offsetHeight;
dom/dom20.html

网页卷去的距离与偏移量
我们先来看看下面的图：
scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。
scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。
offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。
offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。
注意:
1. 区分大小写
2. offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。
dom/dom21.html

编程练习
制作一个表格，显示班级的学生信息。
要求：
1. 鼠标移到不同行上时背景色改为色值为 #f2f2f2，移开鼠标时则恢复为原背景色 #fff
2. 点击添加按钮，能动态在最后添加一行
3. 点击删除按钮，则删除当前行
任务
第一步： 首先，我们创建删除函数，并在删除按钮上添加点击事件；
提示: 使用removeChild()。
第二步： 编写一个函数，供添加按钮调用，动态在表格的最后一行添加子节点；
提示: 使用createElement()、innerHTML、appendChild()。
第三步： 更改鼠标移动改变背景则可以通过给每行绑定鼠标移上事件和鼠标移除事件来改变所在行背景色。
提示:
1. 获取表格的行，getElementsByTagName 。
2. 使用for进行循环，为每行添加事件及背景颜色设置。
dom/practice.html

编程挑战
现在利用之前我们学过的JavaScript知识，实现选项卡切换的效果。
效果图:
文字素材:
房产：

    275万购昌平邻铁三居 总价20万买一居
    200万内购五环三居 140万安家东三环
    北京首现零首付楼盘 53万购东5环50平
    京楼盘直降5000 中信府 公园楼王现房
家居:
     40平出租屋大改造 美少女的混搭小窝
     经典清新简欧爱家 90平老房焕发新生
     新中式的酷色温情 66平撞色活泼家居
     瓷砖就像选好老婆 卫生间烟道的设计
二手房：
     通州豪华3居260万 二环稀缺2居250w甩
     西3环通透2居290万 130万2居限量抢购
     黄城根小学学区仅260万 121平70万抛!
     独家别墅280万 苏州桥2居优惠价248万
任务
大家先思考和分析实现思路，然后在动手实现
一、HTML页面布局
提示:
选项卡标题使用ul..li
选项卡内容使用div
二、CSS样式制作
提示:
整个选项卡的样式设置
选项卡标题的样式设置
选项卡内容的样式设置
一开始只显示一个选项卡内容，其它选项卡内容隐藏。
三、
提示:
获取选项卡标题和选项卡内容
选项卡内容多个，需要循环遍历来操作，得知哪个选项卡和哪个选项内容匹配
通过改变DOM的css类名称,当前点击的选项卡显示，其它隐藏。
summary.html

JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。
但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。
为了解决这个问题，最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：
var m = new Map();
var s = new Set();
alert("你的浏览器支持Map和Set！");
Map

Map是一组键值对的结构，具有极快的查找速度。

举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：
var names = ["Michael", "Bob", "Tracy"];
var scores = [95, 75, 85];
给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。

如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：
var m = new Map([["Michael", 95], ["Bob", 75], ["Tracy", 85]]);
m.get("Michael"); // 95
初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：

var m = new Map(); // 空Map
m.set("Adam", 67); // 添加新的key-value
m.set("Bob", 59);
m.has("Adam"); // 是否存在key "Adam": true
m.get("Adam"); // 67
m.delete("Adam"); // 删除key "Adam"
m.get("Adam"); // undefined

由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
var m = new Map();
m.set("Adam", 67);
m.set("Adam", 88);
m.get("Adam"); // 88

Set

Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
重复元素在Set中自动被过滤：
var s = new Set([1, 2, 3, 3, "3"]);
s; // Set {1, 2, 3, "3"}
注意数字3和字符串"3"是不同的元素。
通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：

>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
通过delete(key)方法可以删除元素：

var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}

iterable
遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。
具有iterable类型的集合可以通过新的for ... of循环来遍历。
for ... of循环是ES6引入的新的语法，请测试你的浏览器是否支持：
var a = [1, 2, 3];
for (var x of a) {
}
alert("你的浏览器支持for ... of");

用for ... of循环遍历集合，用法如下：
var a = ["A", "B", "C"];
var s = new Set(["A", "B", "C"]);
var m = new Map([[1, "x"], [2, "y"], [3, "z"]]);
for (var x of a) { // 遍历Array
    alert(x);
}
for (var x of s) { // 遍历Set
    alert(x);
}
for (var x of m) { // 遍历Map
    alert(x[0] + "=" + x[1]);
}
你可能会有疑问，for ... of循环和for ... in循环有何区别？

for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。

当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果：

var a = ["A", "B", "C"];
a.name = "Hello";
for (var x in a) {
    alert(x); // "0", "1", "2", "name"
}
for ... in循环将把name包括在内，但Array的length属性却不包括在内。

for ... of循环则完全修复了这些问题，它只循环集合本身的元素：
var a = ["A", "B", "C"];
a.name = "Hello";
for (var x of a) {
    alert(x); // "A", "B", "C"
}
这就是为什么要引入新的for ... of循环。

然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：
var a = ["A", "B", "C"];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});
注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。

Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：
var s = new Set(["A", "B", "C"]);
s.forEach(function (element, sameElement, set) {
    alert(element);
});

Map的回调函数参数依次为value、key和map本身：
var m = new Map([[1, "x"], [2, "y"], [3, "z"]]);
m.forEach(function (value, key, map) {
    alert(value);
});

如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：
var a = ["A", "B", "C"];
a.forEach(function (element) {
    alert(element);
});

arguments
JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：
function foo(x) {
    alert(x); // 10
    for (var i=0; i<arguments.length; i++) {
        alert(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：
function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x >= 0 ? x : -x;
}
abs(); // 0
abs(10); // 10
abs(-9); // 9
实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。

rest参数

由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数：
function foo(a, b) {
    var i, rest = [];
    if (arguments.length > 2) {
        for (i = 2; i<arguments.length; i++) {
            rest.push(arguments[i]);
        }
    }
    console.log("a = " + a);
    console.log("b = " + b);
    console.log(rest);
}
为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？
ES6标准引入了rest参数，上面的函数可以改写为：
function foo(a, b, ...rest) {
    console.log("a = " + a);
    console.log("b = " + b);
    console.log(rest);
}
foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]
foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。
如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。
因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和：

标准对象：
在JavaScript的世界里，一切都是对象。
但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串：
typeof 123; // "number"
typeof NaN; // "number"
typeof "str"; // "string"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Math.abs; // "function"
typeof null; // "object"
typeof []; // "object"
typeof {}; // "object"
可见，number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。
包装对象
除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚int和Integer这种暧昧关系。
number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建：
var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String("str"); // "str",生成了新的包装类型
虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false：
typeof new Number(123); // "object"
new Number(123) === 123; // false
typeof new Boolean(true); // "object"
new Boolean(true) === true; // false
typeof new String("str"); // "object"
new String("str") === "str"; // false
所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！
如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？
此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）：
var n = Number("123"); // 123，相当于parseInt()或parseFloat()
typeof n; // "number"
var b = Boolean("true"); // true
typeof b; // "boolean"
var b2 = Boolean("false"); // true! "false"字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(""); // false
var s = String(123.45); // "123.45"
typeof s; // "string"
是不是感觉头大了？这就是JavaScript特有的催眠魅力！
总结一下，有这么几条规则需要遵守：
不要使用new Number()、new Boolean()、new String()创建包装对象；
用parseInt()或parseFloat()来转换任意类型到number；
用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；
通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；
typeof操作符可以判断出number、boolean、string、function和undefined；
判断Array要使用Array.isArray(arr)；
判断null请使用myVar === null；
判断某个全局变量是否存在用typeof window.myVar === "undefined"；
函数内部判断某个变量是否存在用typeof myVar === "undefined"。
最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。
更细心的同学指出，number对象调用toString()报SyntaxError：
123.toString(); // SyntaxError
遇到这种情况，要特殊处理一下：
123..toString(); // "123", 注意是两个点！
(123).toString(); // "123"
不要问为什么，这就是JavaScript代码的乐趣！






