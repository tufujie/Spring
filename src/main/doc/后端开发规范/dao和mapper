调用mapper
（1）insert语句,输入Vo，返回boolean
（2）update 语句,输入Vo，返回boolean
    注意sql执行成功，实际更新0条，导致返回false的情况。根据业务情况处理。
（3）delete语句，输id或者相关联对象的id，返回boolean
（4）select语句，
       输入对象：可以是Vo,  当查询条件都在Vo中
       输入Map对象：当查询过滤字段不在Vo中
       输出Vo对象，Vo与数据库表、页面展示表有映射关系
       输出java.util.HashMap， 当查询结果无法与Vo对应，(不能写java.util.Map，必须是具体的实现类，否则iBatis无法实例化)

禁止一个Dao操作多个表（一个Dao只能对应的表，进行增删改）
尽可能不用关联查询，逐步去掉关联查询，而使用缓存
如果可能， 尽可能表增加冗余字段

关于定义dao方法：
根据查询的主表，将查询的方法定义在主表对应的Dao，sql配置在主表对应的config或mapper文件。
比如： 根据房间ID查询客户，应该方法定义在客户Dao，如果工单的servcie需要用到该查询业务， 在工单的service引入客户Dao

关于逻辑删除：
所有Vo对象启用 逻辑删除修改：
   * (1)插入数据默认为0        此处不需要修改代码。
   * (2)删除后，更改为1        原来的delete脚本全部修改为update脚本。
   * (3)查询数据  FIsDelete = 0   这里多表关联的只需要针对主表。 如果是查询分录数据，那么也需要加上FIsDelete = 0

变化说明
根据逻辑删除，所有数据都不会删除。 这有利于数据分析，究竟哪些数据经常用户会修改删除。
注意事项
◾ (1)各Vo对象不用增加isDelete字段。也不要出现在insert脚本中。对于前端透明。
◾ (2)Update脚本也仅仅是删除脚本中出现FIsDelete=1 不要传参数修改FIsDelete。以免数据错误。
FIsDelete,FDeleteTime 都有默认值， 不要出现在insert脚本和update脚本中。以免数据错误。
仅仅在delete脚本中，更新。
不同的业务用不同的方法
特别说明：方法共用，是同一场景下共用。不同业务场景，就容易出问题。